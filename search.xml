<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[第1章| 并发编程的挑战]]></title>
    <url>%2F2019%2F07%2F24%2F%E7%AC%AC1%E7%AB%A0-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E6%8C%91%E6%88%98%2F</url>
    <content type="text"><![CDATA[不是启动越多的线程，程序就能最大限度地并发执行。并发编程通常会受到上下文切换、死锁、硬件和软件资源等问题的影响。 上下文切换 单核cpu通过为每个线程分配cpu时间片来实现多线程，时间片时长通常为几十毫秒。 上下文切换会影响到多线程的执行速度。 问题： 并发执行的代码是不是肯定比串行执行的快？回答： 不一定，因为多线程的创建和切换上下文也有开销，所以在循环次数较少时，耗时效果并不理想。通常需要百万级别以上，多线程的优势才能被体现出来。 题外话：书中并发代码concurrency()方法部分代码可以用Java8的lambda特性进行修改，具体如下 1234567891011121314151617181920修改前：Thread thread = new Thread(new Runnable() &#123; @Override public void run() &#123; int a = 0; for (long i = 0; i &lt; count; i++) &#123; a += 5; &#125; System.out.println(a); &#125; &#125;); 修改后：Thread thread = new Thread(() -&gt; &#123; int a = 0; for (long i = 0; i &lt; count; i++) &#123; a += 5; &#125; System.out.println(a); &#125;); 上下文切换的开销会影响到整体的耗时，所以因尽量减少上下文切换，可采取以下策略： 无锁并发编程：多线程中减少使用锁的次数，从而减少竞争锁时带来上下文切换的次数，如将数据的ID按照Hash算法取模分段，不同线程处理不同段的数据； CAS算法：利用该算法更新数据，可不需加锁 使用最少线程：适量创建线程个数，减少不必要线程产生的等待时间 协程：在单线程中实现多任务的调度，并在单线程中维持多个任务见的切换，这样就没有多线程的切换。 死锁 死锁的概念当两个或两个以上的进程在执行过程中，双方都在等待对方停止运行，以获取系统资源，但是没有一方提前退出时，就称为死锁。 避免死锁的方法 避免一个线程同时获取多个锁 避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源 尝试使用定时锁，使用lock.tryLock(timeout)来替代使用内部锁机制 对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况。 资源限制的挑战 资源限制概念指在并发编程中，程序的执行速度受到计算机硬件或软件资源影响的情况。硬件资源限制有：带宽、硬盘读写、cpu处理速度等；软件资源限制有：数据库链接数和socket连接数等。 在资源限制情况下，原本将串行代码并发执行以此来加快执行时间，但这种情况下由于资源限制，导致代码仍只能串行执行，但是并发中加入了上下文切换和调度的时间，从而导致整体运行时间不减反增。 处理资源限制方法 硬件资源限制：由于是计算机资源受限，所以可以采用增加计算机个数的方法，如用集群并发执行程序。 软件资源限制：使用资源池复用资源，不使用资源池而频繁地创建销毁连接，会极大地浪费系统资源，增加响应耗时，影响系统性能。 问题总结 CAS算法实现思想是？CAS（比较与交换，Compare and swap） 是一种有名的无锁算法，维护三个变量值，一个是内存值V，一个是期望的旧的值A，一个是要更新的值B。更新一个变量的时候，只有当预期值A与内存V中的值相等的时候，才会执行更新操作，把内存V的值改为B。当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。从思想上来说，synchronized属于悲观锁，悲观地认为程序中的并发情况严重，所以只能在一个线程获取到锁后，其他线程被挂起等待；CAS属于乐观锁，乐观地认为程序中的并发情况不那么严重，所以让线程不断去重试更新。 协程的概念？协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。没有生命周期。 JDK提供了哪些并发容器和工具类可以用来解决并发问题？java.util.concurrent及其子包，具体包含以下几个方面： 提供了几个非常有用的并发工具类，包括CountDownLatch、CyclicBarrier、Semaphore等，可以实现更加丰富的多线程操作。比如利用Semaphore作为资源控制器，限制同时进行工作的线程数量。 各种线程安全的容器，比如最常见的ConcurrentHashMap、有序的ConcurrentSkipListMap，或者通过类似快照机制，实现线程安全的动态数组CopyOnWriteArrayList等。 各种并发队列实现，如各种BlockingQueue实现，比较典型的ArrayBlockingQueue、SynchorousQueue或针对特定场景的PriorityBlockingQueue等。 强大的Executor框架，可以创建各种不同类型的线程池，调度任务运行等。绝大部分情况下，不再需要自己从头实现线程池和任务调度器。 待解决 为什么协程上下文切换要比线程快很多？ 协程起源于其他语言，Java对协程的支持如何？应用场景多吗？]]></content>
      <categories>
        <category>Java并发编程的艺术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql02| 从SQL更新语句看mysql日志系统]]></title>
    <url>%2F2019%2F05%2F12%2FMysql02-%E4%BB%8ESQL%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E7%9C%8Bmysql%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[MySQL 可以恢复到半个月内任意一秒的状态，这是为什么？ mysql的更新语句与查询语句大体相同，但多了两个日志模块即redo log（重做日志）和binlog（归档日志） 一、redo log和binlog1、redo log模块（存储引擎层日志） WAL技术（Write-Ahead Logging）是InnoDB引擎先将“更新”写到redo log中并更新内存，这时候就算更新完毕了，等计算机“空闲”时再写入硬盘当中。 其中redo log是有固定大小的，等被写满时就不得不写入硬盘中了。也正因为有redo log的存在，所以在mysql发生异常重启后，InnoDB就可以记录不丢失，该能力被称为crash-safe。 2、binlog日志模块（server层日志）3、两个日志模块联系与差异 mysql5.5.5以前默认使用自带的MyISAM引擎，该引擎没有crash-safe能力，只能依靠MyISAM进行归档；在 5.5.5 版本后使用InnoDB作为默认存储引擎。 差异处： redo log是InnoDB特有的，而binlog位于server层，所有引擎都可以使用； redo log是物理日志，记录了在实际物理位置进行的操作；binlog是逻辑日志，记录的是执行语句的原始逻辑； redo log是循环写，固定大小会被写完；binlog是追加写，写到一定大小切换到下一个，不覆盖以往内容。 二、update语句执行流程注：下图中浅色在InnoDB中进行，深色在执行器中完成。由上图可知，InnoDB中的操作被分成了两阶段提交，之所以要这样做，是因为只有一步的话，会导致一句日志回复的数据库状态与原数据库状态不同，这样在数据库发生崩溃和扩容时都带来巨大问题。这样做了可以保证redo log和binlog的逻辑一致。 tips:可以将mysql参数innodb_flush_log_at_trx_commit和sync_binlog这两个参数设为1，这样能保证数据库异常重启后物理日志和逻辑日志都不会丢失，因为已经被写到磁盘当中了。]]></content>
      <categories>
        <category>Mysql学习实录</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql01| 从SQL语句执行过程看mysql架构]]></title>
    <url>%2F2019%2F05%2F12%2FMysql01-%E4%BB%8ESQL%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E7%9C%8Bmysql%E6%9E%B6%E6%9E%84%2F</url>
    <content type="text"><![CDATA[MySQL的框架有几个组件, 各是什么作用? 连接器：和客户端建立连接、获取权限、维持和管理连接 查询缓存：查看历史记录中是否存在本次查询结果，有的话直接返回结果，否则继续向下执行。由于查询失效频繁，所以不推荐使用查询缓存（mysql8中已删除查询缓存模块）。 分析器：进行词法分析和语法分析，前者要将各个字符串对应到关键字、表、字段名等，后者将判断输入语句是否满足mysql语法。 优化器：决定使用哪个索引，或决定在join语句中使用哪个表作为驱动表。 执行器：验证完权限后，执行SQL语句，使用表存储引擎提供的接口。]]></content>
      <categories>
        <category>Mysql学习实录</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql34| Join用法记录]]></title>
    <url>%2F2019%2F05%2F12%2FMysql34-Join%E7%94%A8%E6%B3%95%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[如果可以使用被驱动表的索引，join要优于单表查询 ； 不能使用被驱动表的索引，只能用Block Nested-Loop join算法，这样的SQL语句应当弃用； 在使用join时，应当让运行中数据量小的表作为驱动表。]]></content>
      <categories>
        <category>Mysql学习实录</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>Join</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[翻译| Github: Authorizing OAuth Apps]]></title>
    <url>%2F2019%2F05%2F08%2F%E7%BF%BB%E8%AF%91-Github-Authorizing-OAuth-Apps%2F</url>
    <content type="text"><![CDATA[tips：本文为github-API关于授权账号登录其他网站开发文档的个人中文翻译，官网文档对应：Authorizing OAuth Apps 授权OAuth应用程序你可以授权github账号登录其他网站 Github的授权实现支持标准授权码授权类型。你可以用下面描述的web应用流程去获取授权code，然后用code去交换获取token。（不支持隐式授权类型） 遇到问题可以参见下面的文章： 认证请求错误汇总 OAuth应用获取token请求错误汇总 Web应用授权流程 Note: 如果建立了一个Github应用，仍然可以使用OAuth web应用流程，不过二者在方案上还是有区别的。更多内容可见关于Github应用认证和授权用户 应用授权用户步骤如下： 用户重定向去请求Github认证 用户从github重定向回到你的web 你的应用通过access token获取到了API 1. 请求Github认证1GET https://github.com/login/oauth/authorize 当你的Github应用指定了login参数，它会给用户一个特定的账户去登录和授权你的应用。 参数|Name|Type|说明||:-:|:-:|:-||client_id|string|必需有。当你注册Github授权应用时产生的client ID||redirect_uri|string|Github授权后返回你的应用地址。更多细节参考redirect urls||login|string|意味着一个用来登录和授权应用的特定账户||scope|string|以空格分隔的scope列表。如果此处为空，scope默认对用户是一个空的列表，即没有对应用授权任何scope，在OAuth授权页面的scopes列表中也不会有该用户。对应地，这一步工作流程将会自动完成授权应用的用户scope集。例如，一个用户已经执行web授权流程两次，用userscope和reposcope各授权了一次，那么第三次web流程没有提供scope时也会受到前面userscope和reposcope得到的token。||state|string|一个不可预计的随机字符串，被用作为保护伪造跨域请求攻击。||allow_signup|string|无论用户是否认证，都将被提供一个选项在OAuth流程中是否要注册Github。默认是true，在政策禁止注册下可使用false。 2. 用户从Github重定向回到你的网站如果接受了你的请求，Github会重定向回到你的网站，并携带一个临时的code在code参数中，还在state参数中携带了上一步你提供的state。临时的code将在10分钟后失效。如果states不匹配，那么第三方将会创建请求，并且你需要中断当前操作。 用code取交换获取access token: 1POST https://github.com/login/oauth/access_token 参数|Name|Type|说明||:-:|:-:|-||client_id|string|必需有。当你注册Github授权应用时产生的client ID||client_secret|string|必需有。当你注册Github授权应用时产生的client secret||code|string|必需有。你收到的code是对应step1中的||redirect_uri|string|是你应用中的URL，这个地址用作用户授权返回地址||state|string|step1中你提供的随机字符串| 响应通常，得到的响应一般为下面这种形式： 1access_token=e72e16c7e42f292c6912e7710c838347ae178b4a&amp;token_type=bearer 你也有可能因为Accpt header形式的不同接收到不同的内容 123456789Accept: application/json&#123;"access_token":"e72e16c7e42f292c6912e7710c838347ae178b4a", "scope":"repo,gist", "token_type":"bearer"&#125;Accept: application/xml&lt;OAuth&gt; &lt;token_type&gt;bearer&lt;/token_type&gt; &lt;scope&gt;repo,gist&lt;/scope&gt; &lt;access_token&gt;e72e16c7e42f292c6912e7710c838347ae178b4a&lt;/access_token&gt;&lt;/OAuth&gt; 3. 利用access token去获取APIaccess token可以让你以用户的身份请求API 12Authorization: token OAUTH-TOKENGET https://api.github.com/user 例如，你可以像下面这样用curl设置header： 1curl -H "Authorization: token OAUTH-TOKEN" https://api.github.com/user 非Web应用授权流程基于Basic Authentication利用接口去创建OAuth2 token。通过这种方法，用户名和密码不需要被永久存储，而且用户可以在任何时候撤销access。 Note: 当使用非Web应用授权流程创建OAuth2 token时，如果你或你的用户是双重认证的话，应确保理解双重认证机制 Redirect URLsredirect_uri参数是可选的。如果省略，Github将重定向用户到callback URL，这一地址被配置在了OAuth Application settings部分。如果提供了，redirect URL的主机和端口必须准确匹配callback URL。redirect URL路径必须引用callback URL的子目录。 123456789CALLBACK: http://example.com/pathGOOD: http://example.com/pathGOOD: http://example.com/path/subdir/otherBAD: http://example.com/barBAD: http://example.com/BAD: http://example.com:8080/pathBAD: http://oauth.example.com:8080/pathBAD: http://example.org 为OAuth应用创建多个token你可以为user/application/scope组合创建多个token用作特定用途。 如果你的OAuth应用支持使用Github登录，并且一个工作流只需要用户的基本信息，另一个工作流可能需要获取用户私有资料，这样创建多个token是可行的。使用多个token，你的OAuth应用就可以根据不同用途执行不同web工作流，只需要请求scope需要的。如果一个用户仅使用你的应用去登录，他们就不会去授权你的OAuth应用去获取他们的私有资料。 每次的user/application/scope组合发布的token数量有限定，如果你的应用对其中一个限定请求了足够多的token，那么位于同一scope的旧token就会停止工作。 Warning: 撤销OAuth应用的所有许可会删除代表应用产生的表征用户的所有SSH keys，其中包括deploy keys。 重定向用户去检查他们的access你链接到OAuth应用的授权信息，用户就可以检查和取消他们的应用授权。 为了建立这个链接，需要注册OAuth应用时从Github接收到的client_id。 1https://github.com/settings/connections/applications/:client_id tips: 了解更多关于OAuth应用访问用户详见”Discovering resources for a user.”]]></content>
      <categories>
        <category>码农笔记</category>
      </categories>
      <tags>
        <tag>文档翻译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[03| 计算机网络相关知识]]></title>
    <url>%2F2019%2F04%2F09%2F03-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[知识点汇总 1. 4/7层网络模型（&hearts;&hearts;&hearts;）[^1] OSI七层 TCP/IP四层 网络协议 应用层（Application） 应用层 HTTP、TFTP, FTP, NFS, WAIS、SMTP 表示层（Presentation） 应用层 Telnet, Rlogin, SNMP, Gopher 会话层（Session） 应用层 SMTP, DNS 传输层（Transport） 传输层 TCP, UDP 网络层（Network） 网络层 IP, ICMP, ARP, RARP, AKP, UUCP 数据链路层（Data Link） 数据链路层 FDDI, Ethernet, Arpanet, PDN, SLIP, PPP 物理层（Physical） 数据链路层 IEEE 802.1A, IEEE 802.2到IEEE 802.11 2. TCP协议2.1 三次握手建连2.2 四次挥手断连2.3 报文状态标志与连接状态[^2]LISTEN：侦听来自远方的TCP端口的连接请求 SYN-SENT：再发送连接请求后等待匹配的连接请求 SYN-RECEIVED：再收到和发送一个连接请求后等待对方对连接请求的确认 ESTABLISHED：代表一个打开的连接 FIN-WAIT-1：等待远程TCP连接中断请求，或先前的连接中断请求的确认 FIN-WAIT-2：从远程TCP等待连接中断请求 CLOSE-WAIT：等待从本地用户发来的连接中断请求 CLOSING：等待远程TCP对连接中断的确认 LAST-ACK：等待原来的发向远程TCP的连接中断请求的确认 TIME-WAIT：等待足够的时间以确保远程TCP接收到连接中断请求的确认 CLOSED：没有任何连接状态 2.4 Nagel算法与ACK延迟2.5 Keepalive2.6 滑动窗口与流量控制[^1]:好就分享. OSI七层协议模型、TCP/IP四层模型学习笔记[^2]:mei922. TCP连接状态详解]]></content>
      <categories>
        <category>JAVA知识点梳理</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常用命令]]></title>
    <url>%2F2019%2F04%2F01%2FLinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[此部分主要考察java从业者的线上问题排查能力，现基于CentOS release 6.5 (Final)简要介绍如下6个命令[^1]，期间用poem文件举例。推荐查询linux命令的两个网址Linux 命令大全 | 菜鸟教程Linux命令大全(手册)。 123456789cat poem******结果******1 --------------------------2 The Noon Balloon3 Will be leaving soon4 For the sun or the moon.5 And wherever it goes,6 It will get there too soon.7 -------------------------- awk命令：好用的数据处理工具（默认分隔符：空格或tab）sed常用作一整行的处理，awk则倾向于将一行分成数个“字段”处理，适合小型数据处理。 语法：awk ‘条件类型1 {动作1} 条件类型2 {动作2}…’ filenamee.g. 输出poem中第2行至第6行的第2列与第4列内容以及第1列乘10结果，中间以#符分割（提示：NR为当前处理行的行号） 1234567awk &apos;NR&gt;=2 &amp;&amp; NR&lt;=6 &#123;print $2&quot;#&quot;$4&quot;#&quot;$1*10&#125;&apos; poem******结果******The#Balloon#20Will#leaving#30For#sun#40And#it#50It#get#60 top命令：动态查看进程变化 语法：top [-d 数字] | top [-bnp]-d 页面刷新时间间隔描述，本次所用系统默认3秒-b 以批次的形式展现-n 执行几次后停止-p 查看进程号为p的进程动态 e.g. 每隔3秒批次查看进程号为1673的进程3次，然后结束。top -d 3 -b -n 3 -p 1673 netstat命令：跟踪网络 语法：netstat -[atunlp]-a 显示系统所有连接、监听、Socket-t 列出tcp网络数据包的数据-u 列出udp网络数据包的数据-n 不列出进程的服务名称，以端口号显示-l 列出正在监听的服务-p 列出进程号为PID的进程e.g. 累出目前系统已经新建的网络连接与Unix Socket状态netstat 123456789101112131415Active Internet connections (w/o servers)Proto Recv-Q Send-Q Local Address Foreign Address State tcp 0 1 node4:42278 node1:intu-ec-svcdisc SYN_SENT tcp 0 1 node4:59492 node2:intu-ec-svcdisc SYN_SENT tcp 0 0 node4:ssh 192.168.226.1:56589 ESTABLISHED tcp 0 132 node4:ssh 192.168.226.1:53859 ESTABLISHED tcp 0 0 node4:8031 node4:32834 ESTABLISHED tcp 0 1 node4:44307 node1:eforward SYN_SENT tcp 0 0 node4:32834 node4:8031 ESTABLISHED Active UNIX domain sockets (w/o servers)Proto RefCnt Flags Type State I-Node Pathunix 14 [ ] DGRAM 11626 /dev/logunix 2 [ ] DGRAM 9228 @/org/kernel/udev/udevdunix 2 [ ] DGRAM 12430 @/org/freedesktop/hal/udev_event…（省略）… grep命令：分析一行数据，后边常跟正则表达式 语法：grep [-acinv] [–color=auto] ‘查找字符串’ filename-a 将binary文件以text文件方式查找数据-c 计算找到’查找字符串’的次数-i 忽略大小写的不同-n 输出行号-v 输出没有’查找字符串’的那一行e.g. 输出poem包含’l’字符的几行，顺带输出行号grep -n &#39;l&#39; poem 1232:2 The Noon Balloon3:3 Will be leaving soon6:6 It will get there too soon. less命令：一页一页翻动（往前往后翻）由于poem文件长度较短，不便演示 tail命令：取出后面几行 语法：tail -ne.g. 显示poem后两行 1234tail -n 2 poem******结果******6 It will get there too soon.7 -------------------------- [^1]:鸟哥. 鸟哥的Linux私房菜[M]. 北京: 人民邮电出版社, 2016.]]></content>
      <categories>
        <category>码农笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[继承Thread类和实现Runnable接口法的异同]]></title>
    <url>%2F2019%2F03%2F31%2F%E7%BB%A7%E6%89%BFThread%E7%B1%BB%E5%92%8C%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3%E6%B3%95%E7%9A%84%E5%BC%82%E5%90%8C%2F</url>
    <content type="text"><![CDATA[导语：在java中实现多线程的方法有两种：继承Thread类和实现Runnable接口。在使用这两种方法创建多线程类时有什么不同呢？下面作简要分析。 一、继承Thread类法1.1. 这里先给出一个小demo，实现代码如下： 1234567891011121314151617181920212223class MyThread extends Thread &#123; private String name; public MyThread(String name) &#123; this.name = name; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) System.out.println(Thread.currentThread().getName() + &quot;+&quot; + name + &quot;+运行了+&quot; + (i + 1) + &quot;次&quot;); &#125;&#125;public class ThreadDemo1 &#123; public static void main(String[] args) &#123; MyThread mt_A = new MyThread(&quot;线程A&quot;); MyThread mt_B = new MyThread(&quot;线程B&quot;); System.out.println(&quot;当前线程为：&quot; + Thread.currentThread().getName()); mt_A.start(); mt_B.start(); &#125;&#125; 运行结果（某次）： 123456789101112131415161718192021当前线程为：mainThread-1+线程B+运行了+1次Thread-0+线程A+运行了+1次Thread-1+线程B+运行了+2次Thread-0+线程A+运行了+2次Thread-1+线程B+运行了+3次Thread-0+线程A+运行了+3次Thread-1+线程B+运行了+4次Thread-0+线程A+运行了+4次Thread-1+线程B+运行了+5次Thread-0+线程A+运行了+5次Thread-1+线程B+运行了+6次Thread-0+线程A+运行了+6次Thread-1+线程B+运行了+7次Thread-0+线程A+运行了+7次Thread-1+线程B+运行了+8次Thread-0+线程A+运行了+8次Thread-1+线程B+运行了+9次Thread-0+线程A+运行了+9次Thread-1+线程B+运行了+10次Thread-0+线程A+运行了+10次 从运行结果可以看出，开启了两个新线程Thread-0和Thread-1，两个线程互相抢占资源完成了打印操作，实现了多线程操作！ 1.2. 为什么用start()启动线程而不是用run()方法？ 因为线程的运行需要本地操作系统的支持，先分别来看看start()和run()方法的源码。 1234567891011121314151617181920/*start()方法源码*/ public synchronized void start() &#123; if (threadStatus != 0) //如果当前线程不处于就绪状态，启动时就报错 throw new IllegalThreadStateException(); group.add(this); boolean started = false; try &#123; start0(); started = true; &#125; finally &#123; try &#123; if (!started) &#123; group.threadStartFailed(this); &#125; &#125; catch (Throwable ignore) &#123; &#125; &#125; &#125; private native void start0(); 在上面代码中出现了关键字native，表明了start0()是一个本地方法，说明start0()方法的运行需要本地操作系统的支持。 1234567/*run()方法源码*/ @Override public void run() &#123; if (target != null) &#123; target.run(); &#125; &#125; （1）从上面两处代码可以看出： start()方法最后是由start0()方法完成，它会新运行一个线程，新线程会调用run()方法，且start()方法不能被重复调用[1]，否则会抛出IllegalThreadStateException异常。 run()方法同一般成员方法一样，可以被重复调用。单独调用run()的时不会启动新线程，而是继续在当前线程中执行run()。为了验证run()方法不会启动新线程，可以将1.小demo中的mt_A.start();mt_B.start();改为mt_A.run();mt_B.runt();运行结果（每次相同）：123456789101112131415161718192021当前线程为：mainmain+线程A+运行了+1次main+线程A+运行了+2次main+线程A+运行了+3次main+线程A+运行了+4次main+线程A+运行了+5次main+线程A+运行了+6次main+线程A+运行了+7次main+线程A+运行了+8次main+线程A+运行了+9次main+线程A+运行了+10次main+线程B+运行了+1次main+线程B+运行了+2次main+线程B+运行了+3次main+线程B+运行了+4次main+线程B+运行了+5次main+线程B+运行了+6次main+线程B+运行了+7次main+线程B+运行了+8次main+线程B+运行了+9次main+线程B+运行了+10次 从执行结果可以看出，上述字符串的打印都是在主线程中完成的，未开启新线程，并且打印是按照先A后B的顺序执行的！ 二、实现Runnable接口法2.1. 同样这里给出此方法实现的小demo，代码如下： 123456789101112131415161718192021class MyRunnable implements Runnable &#123; private int ticket = 10; @Override public void run() &#123; for (int i = 0; i &lt; 50; i++) &#123; if (ticket &gt; 0) &#123; System.out.println(Thread.currentThread().getName() + &quot;+sell ticket:&quot; + ticket--); &#125; &#125; &#125;&#125;public class ThreadDemo2 &#123; public static void main(String[] args) &#123; MyRunnable my = new MyRunnable(); new Thread(my).start(); new Thread(my).start(); new Thread(my).start(); &#125;&#125; 运行结果如下： 12345678910Thread-1+sell ticket:10Thread-2+sell ticket:8Thread-0+sell ticket:9Thread-2+sell ticket:6Thread-1+sell ticket:7Thread-2+sell ticket:4Thread-2+sell ticket:2Thread-2+sell ticket:1Thread-0+sell ticket:5Thread-1+sell ticket:3 由结果可知使用Runnable接口的方式，完成了买票的业务。即用3个线程一块进行卖票，每张票只卖了一次，符合实际情况。 2.2. 用继承Thread类的方法执行卖业务时，就会发现行不通，具体情况如下： 12345678910111213141516171819class MyRunnable extends Thread &#123; private int ticket = 10; @Override public void run() &#123; for (int i = 0; i &lt; 50; i++) &#123; if (ticket &gt; 0) &#123; System.out.println(Thread.currentThread().getName() + &quot;+sell ticket:&quot; + ticket--); &#125; &#125; &#125;&#125;public class ThreadDemo2 &#123; public static void main(String[] args) &#123; new MyRunnable().start(); new MyRunnable().start(); new MyRunnable().start(); &#125;&#125; 运行结果如下 123456789101112131415161718192021222324252627282930Thread-0+sell ticket:10Thread-1+sell ticket:10Thread-1+sell ticket:9Thread-0+sell ticket:9Thread-1+sell ticket:8Thread-2+sell ticket:10Thread-1+sell ticket:7Thread-0+sell ticket:8Thread-1+sell ticket:6Thread-2+sell ticket:9Thread-1+sell ticket:5Thread-0+sell ticket:7Thread-1+sell ticket:4Thread-1+sell ticket:3Thread-1+sell ticket:2Thread-1+sell ticket:1Thread-2+sell ticket:8Thread-0+sell ticket:6Thread-2+sell ticket:7Thread-0+sell ticket:5Thread-2+sell ticket:6Thread-0+sell ticket:4Thread-2+sell ticket:5Thread-0+sell ticket:3Thread-2+sell ticket:4Thread-0+sell ticket:2Thread-2+sell ticket:3Thread-0+sell ticket:1Thread-2+sell ticket:2Thread-2+sell ticket:1 由运行结果可知，此处的三个线程各卖了10张票，与实际情况不符。 三、小结 Thread类也实现了Runnable接口，应尽量使用实现Runnable的方式，因为实现Runnable接口的方式比继承Thread类方法多以下优势：① 适合多个相同程序代码的线程去处理同一资源；② 避免了Java单继承带来的局限性；③ 增强了程序的健壮性，代码能被多个线程共享，代码与数据是独立的。 [1]:skywang12345. Java多线程系列–“基础篇”03之 Thread中start()和run()的区别]]></content>
      <categories>
        <category>码农笔记</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[02| 操作系统相关知识]]></title>
    <url>%2F2019%2F03%2F29%2F02-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[知识点汇总 操作系统部分知识有助于对服务问题进行排查定位，主要考察了解和应用，在面试中所占比较小。 1. 进程与线程（&hearts;&hearts;&hearts;）1.1 进程与线程之间的区别与联系？ 进程，是系统资源分配的最小单位，使用独立的数据空间 线程，是程序执行的最小单位，共享进程的数据空间 1.2 线程的状态线程一般包含5种状态[^1]：创建、就绪、运行、阻塞和终止。有的会把线程状态分为6种[^2]：初始、运行、阻塞、等待、超时等待和终止，这种的将原来5种状态中的就绪和运行统称为运行，把原来阻塞细分为了阻塞、等待、超时等待三种。这样-1+2就相当于多增加了1种状态，这里还是采用经典的5种线程状态说法，可以用图1来表示5种线程状态之间的关系。 创建状态继承Thread类和实现Runnable接口都可创建一个线程，此时的线程处于创建状态。（这里扩展一点——「多线程」继承Thread类和实现Runnable接口法的异同） 就绪状态当start()方法执行后，线程就进入了就绪状态。这时线程就处在了线程队列当中，等待CPU资源，代表其已经具备运行的资格。 运行状态当处于就绪状态的线程获得CPU资源时，该线程就进入了运行状态，此时run()方法中定义的操作将被执行。 阻塞状态运行状态的线程由于某些原因放弃了对CPU的使用权，这时候的线程就进入了阻塞状态，当引起阻塞的原因被解除时，线程才重新可以进入就绪状态。一般阻塞状态可以分为以下三种[^3]：（1）等待阻塞：执行wait()方法，该线程会释放占用的所有资源，JVM会把该线程放入“等待池”中。进入这个状态后，是不能自动唤醒的，必须依靠其他线程调用notify()或notifyAll()方法才能被唤醒；（2）同步阻塞：在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入“锁池”中，等待其他线程释放同步锁。（3）其他阻塞：执行sleep()或join()方法，或者发出了耗时的输入/输出请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者输入/输出处理完毕时，线程重新转入就绪状态。 终止状态线程的run()方法结束自然死亡或未捕获的异常导致run()方法终止，都会让该线程进入终止状态也就不具备继续运行能力了。判断线程是否终止，可用isAlive()方法。 1.3 线程调度（调度算法）[^4]在分析各种调度算法前，先简要了解一下分时系统与实时系统[^5]（典型的分时系统有UNIX和Linux，而对于windows，严格上说它的本质应该是多种集合的操作系统，它在运行过程中，根据不同的进程会有实时响应和分时响应，部分功能中，它也可以实现分布式操作。）。简单来说分时系统和实时系统都具备多路性（能为多个终端提供服务）和独立性（每个终端之间互不干扰），在及时性方面分时系统考虑的时间是在人可接受的范围内，而实时系统由于军事、工业、多媒体等特定业务的执行需要将时间控制在秒级、百毫秒级直至毫秒级甚至0.1毫秒；在交互性方面，分时系统具备该特性不必说，而实时信息处理系统具备的交互性也仅限于特定的服务程序；至于可靠性，实时系统此方面的要求要比分时系统高的多。 时间片轮转调度（Round Robin, RR）CPU为让每个线程看起来像在并行执行而分配出一个线程运行的时长，也就是时间片。每个就绪状态的线程在排队队列中将按时间片长依次循环执行，直至所有线程运行完毕。 先来先服务调度（First Come First Serve, FCFS）该调度方法仅考虑就绪状态的线程在排队队列中的先后顺序，不考虑其他因素，按照从队首到队尾的顺序依次执行每个线程，只有当该线程运行完毕或因其他原因被阻塞时才运行下一个线程。这种调度简单易行，是一种非抢占式调度策略。比较有利于长作业，而不利于短作业；有利于CPU繁忙的作业，而不利于I/O繁忙的作业。[^6] 优先级调度（Task Switching, TS）[^7][^8][^9]可以通过setPriority()方法来设定线程的优先级，优先级有10个梯度（1~10），即（MIN_PRIORITY【最低1级】—-&gt;……—-&gt;NORM_PRIORITY【普通5级】……—-&gt;MAX_PRIORITY【最高10级】）。处于就绪状态的两个线程，高优先级的线程比低优先级的线程具有更大的概率被CPU执行。至于为什么优先级高的线程不一定先执行，可参见[^10]。 多级反馈队列调度（Multilevel Feedback Queue Scheduling, MFQS）[^11]UNIX操作系统采取的便是这种调度算法。 NOTE1：假设有三个待调度的队列Q1、Q2和Q3，优先级依次递减。进程在进入待调度的队列等待时，首先进入优先级最高的Q1等待。 NOTE2：首先调度优先级高的队列中的进程。若高优先级中队列中已没有调度的进程，则调度次优先级队列中的进程。NOTE3：对于同一个队列中的各个进程，按照时间片轮转法调度。比如Q1队列的时间片为N，那么Q1中的作业在经历了N个时间片后若还没有完成，则进入Q2队列等待，若Q2的时间片用完后作业还不能完成，一直进入下一级队列Q3，直至完成。 NOTE4：在低优先级的队列中的进程在运行时，又有新作业达到最高优先级队列，那么在运行完这个时间片后，CPU马上分配给新到达的作业（抢占式）。 高响应比优先调度（Highest Response Ratio Next， HRRN）该调度策略既考虑作业的执行时间也考虑作业的等待时间，综合了先来先服务和最短作业优先两种算法的特点。但每次调度之前都要计算响应比，这也增加了系统开销，响应比公式定义如下： 响应比 =（等待时间+要求服务时间）/ 要求服务时间=1+等待时间/要求服务时间，可以看出响应比是大于1的。由响应比公式可知：(1) 如果线程的等待时间相同，则线程要求服务的时间愈短，其优先级愈高，因此该调度类似于短作业优先调度；(2) 如果线程要求服务的时间相同，则线程等待时间愈短，其优先级愈高，因此该调度类似于先来先服务调度；(3) 对于要求服务时间长的进程，进程的优先级可以随等待时间的增加而提高，因此也能随着优先级的提高得到服务。 1.4 线程切换步骤[^12] 多线程不一定就比单线程程序跑的快，因为多线程应用程序会带来额外的开销和竞争问题，可能会拖慢系统的执行速度。这些因素包括：对IO设备的竞争，对锁的竞争，以及CPU对线程执行上下文的频繁切换等。 线程的上下文一般指包括cpu的寄存器和程序计数器在某一时间点的内容等 线程的上下文切换与切换代价当 CPU 从执行一个线程切换到执行另外一个线程的时候，它需要先存储当前线程的本地的数据，程序指针等，然后载入另一个线程的本地数据，程序指针等，最后才开始执行。这种切换称为“上下文切换”(“context switch”)。CPU 会在一个上下文中执行一个线程，然后切换到另外一个上下文中执行另外一个线程。 线程在运行的时候除了需要从计算机里面获得【CPU资源】，还需要一些【内存】来维持它本地的【堆栈】，还需要占用操作系统中一些资源来【管理线程】。 1.4 Linux下的进程间通信（InterProcess Communication, IPC）面试中间件研发时常考察，了解以下6种进程间通信的相关原理[^13] 共享内存（适用于进程间数据共享场景） UnixSocket（适用于进程间数据交换场景） MessageQueue消息队列（适用于进程间数据交换场景） Pipe管道 Signal Semaphone信号量 1.5 协程 （1）协程又称为“微线程”，是一种用户态的轻量级线程（协程的调度完全由用户控制）。协程拥有自己的寄存器上下文和栈，调度切换时直接操作栈而基本没有内核切换的开销，所以其切换的代价要比线程上下文切换小很多，另外它可以不加锁的访问全局变量。（2）java的第三方协程框架，如Kilim和quasar。 2. Linux常用命令3. 死锁 两个线程都在等待对方先完成，造成了程序的停滞，一般程序的死锁都是在程序运行时出现的。 4. 内存分页管理与SwapLinux中关于swap、虚拟内存和page的区别 5. 任务队列与CPU Load任务队列，消息队列和rpc的区别是什么？CPU负载和 CPU使用率 6. 知识点扩展（了解）6.1 内存屏障 内存屏障，也称内存栅栏，内存栅障，屏障指令等， 是一类同步屏障指令，是CPU或编译器在对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作。 6.2 指令乱序（转）CPU乱序执行原理 6.3 CPU亲和性（affinity）Linux中CPU亲和性(affinity) 6.4 Netfilter和iptablesnetfilter/iptables 简介 [^1]:李兴华. Java开发实战经典[M]. 北京: 清华大学出版社, 2009, 281-282. [^2]:潘建南. Java线程的6种状态及切换(透彻讲解) [^3]:积极解放. JAVA 线程状态及转化 [^4]:超人. 线程调度算法分析 [^5]:___Blue_H. 分时操作系统与实时操作系统 [^6]:Coding-lover. 进程和线程调度算法 [^7]:诺贝尔爱情奖. Java线程的优先级 [^8]:潜行的Q. java的线程优先级和守护线程 [^9]:FangZheng. 线程的优先级 [^10]:强迫症Kobe. 为什么优先级高的线程并不一定先执行 [^11]:taxue505. 多级反馈队列调度算法 [^12]:比特流. 多线程的代价及上下文切换 [^13]:易霂. 6种Linux进程间的通信方式]]></content>
      <categories>
        <category>JAVA知识点梳理</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01| 职业未来发展]]></title>
    <url>%2F2019%2F03%2F28%2F01-%E8%81%8C%E4%B8%9A%E6%9C%AA%E6%9D%A5%E5%8F%91%E5%B1%95%2F</url>
    <content type="text"><![CDATA[1. 职业晋升通道这里用图1表示JAVA从业者的职位晋升过程。。。。。 从图1可以看出在经历1~3年从工程师晋升到高级工程师后，有两个方向可以选择；一个是走技术方向，另一个是走管理方向，先分别讨论如下。 1.1 技术方向 重点培养自己以下3种能力：(1) 技术攻坚能力(2) 架构设计(3) 专业知识需要做到疑难问题的排查、大型项目的功能拆分、技术品牌的塑造等；具体工作有原理实现、注重框架能力的培养；更深一层的还有大规模高并发场景，高可用可扩展措施和方案，业务的抽象和架构能力，分布式服务设计原则的理解等。 1.2 管理方向 重点培养自己以下3种能力：(1) 团队管理(2) 项目管理(3) 沟通协作偏重于团队把控，需要让团队形成技术战斗力，利用一切资源推进项目，让团队完成作战目标。另外做好团 队内和跨团队的沟通协作也是很重要的一块 * 需要重点说明一下，这两个方向没有明显边界，也就是说做管理的不会远离架构设计，做技术专家也需要带队，二者的区分在于侧重点不同，前者更偏向于技术架构而后者更偏向于管理项目推进。 PS：在面试被问及相关问题时，可参考如下例子： 答：从过往的经验来看，我对项目的整体规划、管理推进，在任务推进协调沟通方面有过突出的表现，所以我的职业规划是成为一名优秀的技术经理，并以管理方向为发展目标。（这样答，面试官可能会对你的相关经历产生兴趣。） 2. 常见技术级别划分 职级 工作年限 B（百度） A（阿里） T（腾讯） 备注 工程师 1~3年 多为校招内部晋升，较少为社招 高级工程师 2~5年 T4 P5 T2-2 技术主力，公司看重此级别人才的培养与成长 资深工程师 3~6年 T5 P6 T2-3 技术主力，公司看重此级别人才的培养与成长 技术专家 4~8年 T6 P7 T3-1 一般需要5年从业经验以上 高级技术专家 5~10年 T7 P8 T3-3 一般需要5年从业经验以上 3.如何选择公司和岗位 在换工作时，应聘公司有多个技术岗位，需要都投吗？手里有多个offer，如何进行决策？应当选钱多的还是大平台、福利待遇好的？ 一般来说可从以下几个维度进行考虑(1) 公司规模大小 大厂适合镀金，提高身价 (2) 业务线或团队的重要程度 核心业务适合长期稳定的发展，在核心团队对自身能力和经验提升得较快； 边缘业务有因公司战略调整而被裁掉的风险。综合这两点来说，大公司核心业务竞争压力大，小公司边缘业务应尽量避免；对于工作1~3年的推荐去小公司核心业务，因为职业生涯前期需要更多的基础知识历练场景。 (3) 个人条件的匹配程度 首先需要对自身条件进行评估，评估因素应包含岗位要求、业务方向、自身能力兴趣经验，匹配度与面试成功率成正比，匹配度越高将越利于以后个人的职业发展。 总结就是：优先选择核心业务和与自己条件匹配度高的岗位。 4.面试流程具体面试流程参见图2。 前置面试需要确定是否有笔试、电话面试、上机编程等，同时需要沟通好相关细节，如电话面试时间，上机编程是否需要自带电脑等等（现多为邮件发送笔试地址，用浏览器即可）; 技术一面为正式面试的开始，有1~2位面试官，以考察基础知识与实际应用能力为主，时长一小时左右；可能要求手写小算法，如排序、字符串处理等； 技术二面仍以技术为主，侧重于考察技术深度，比如项目经历、架构能力、算法等。面试时长一小时左右，可能要求画出项目的架构图或交互流程图等，并对项目存在的问题和改进方案进行询问；（规模较小的公司到二面就结束了） 技术三面注重考察项目经历和架构设计，还会设计到职业规划、职业兴趣，技术视野等方面的问题，以架构能力、技术敏感度和发展潜力为主；（少部分公司存在技术四面，如Tencent在较高岗位的面试中，存在跨部门的交叉面试，面试内容与技术三面内容基本相同） 人事面一般考察个人发展规划，上家公司离职原因，价值观，薪资待遇等，如果特别期望进入该公司，不可因为1~2k导致因小失大，因为工作前期以积累为主，三年后谈待遇也不迟。 上级领导面为公司级高管面试，这种非技术面视情况而定，一般为1~2面。可能简单询问工作经历，对公司的看法，对行业的看法，未来规划等，一般无原则性错误均可顺利通过。总结：（1）面试前询问时候有电话面试、笔试、上机等前置面试等；（2）技术一面二面偏重实际工作能力，技术二面三面偏重架构能力和发展能力；（3）二面与三面通常决定入职后的职位级别，也就直接对应着与HR谈薪资的底气了，应当好好表现。 面试前的准备工作对面试能否成功起着关键作用，面试成功的三个重要因素：能力、心态、沟通。所以面试前应该做好哪些准备工作？ 能力（1）了解应聘公司及岗位信息（2）系统复习基础知识（3）对负责过的项目进行提炼，从架构方面重新梳理总结项目经历（4）对经典框架原理、使用场景和实现方式进行学习（5）对常考考点进行专项突击，阅读常考考点源码（6）对业务方面进行有针对性的加分准备，比如面试中间件方向岗位，可以突出自己有存储中间件的开发经历，有过链路协议设计经历等。心态（1）面试前多渠道搜集面试公司岗位所属团队平均福利等资料信息，增加信心；（2）当面临压力面试时，需要多给予自己心里暗示，控制情绪；沟通（1）提前准备一个简单有特色的自我介绍，主要描述自己的技术特长和职业优势，禁忌谈及兴趣爱好星座等不重要内容；（2）关于不会的问题，应主动坦白并提出自己的解题思路，不然容易造成冷场；另外也可以选择询问面试官能够换个问题；（3）当没有听明白面试官的问题时，不要着急作答，应及时沟通确认问题；（4）注意面试细节，如面试微表情，面试过程中应尽量不要皱眉、控制坐姿和手势、注意语速、表达逻辑清晰观点明确，不要随意打断面试官，表现出谦虚有礼的面试态度等。另外可以观察面试官的反应，如果TA在简历上奋笔疾书，说明你提供的信息有用；如果停下来很长时间不写了，应提醒自己是否跑题；若面试官表现出不耐烦或深呼吸，应注意自己是否领会了面试官的考察意图，可以再次询问。 面试考察点一般分为硬技能和软实力（1）硬技能：基础知识的掌握、过往的项目经验、系统架构的设计能力、对不同框架工具的综合应用能力；（2）软实力：逻辑思维的灵活与否、沟通表达协作能力、项目管理推进能力、新技术学习思考能力、培养潜力； 不同职级面试考察的区别（1）初/中级工程师 首先是能完成分配的研发任务，面试官就偏重于基础知识掌握、逻辑思维的灵活性、有无培养潜力；其次是过往项目经历与学习思考能力；出于对工作年限的考虑，对架构能力、管理推进、沟通协作能力不作过高要求；（2）高级工程师一般需要独立完成功能模块或是子项目的设计与开发，比初/中级工程师对项目经验、学习思考、架构能力、管理推进、沟通协作能力有更高要求，特别是项目经验与学习思考能力；（3）技术专家在高级工程师的要求上，对项目架构、项目经验、管理推进、协作沟通能力有相当高要求，能够独立负责一个项目，做好项目架构，完成功能模块的拆解和任务分配，推进团队内外部的事务，协调资源管理进度，带领团队完成任务目标。提示：软实力突出会对技术工程师的职业生涯大大加分！ 硬技能学习的四大部分详情参见图3]]></content>
      <categories>
        <category>JAVA知识点梳理</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>职业发展]</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[00| 前言：构建能力框架]]></title>
    <url>%2F2019%2F03%2F27%2F00-%E6%9E%84%E5%BB%BA%E8%83%BD%E5%8A%9B%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[Java技术目前应用广泛，工作求职者众多，取得高薪报酬是码农自身水平的直接体现，这里将Java求职中需要掌握的内容分为以下3个部分。 1. 基础部分 技术岗位与面试流程 计算机基础 JVM原理 多线程 设计模式 数据结构与算法2. 应用部分 常用工具集 常用框架 缓存 队列 数据库3. 综合部分 系统架构设计 微服务架构 容器化 找工作面对的3个问题 如何准备简历？ 简历直接决定着求职者能否获得面试机会，所以简历的重要性不言而喻！有数据显示80%的简历通不过初步筛查，原因有：(1) 工作或项目经验描述不到位(2) 不懂得如何包装技术特长(3) 不占优的学历放在了最重要的位置(4) 排版较乱，语言不精练 补充：不可进行不看岗位的盲目海投，要根据岗位要求及时调整简历；简历中工作年限，对口经验、学历、简历美观度都需要留意。 面试官会考什么问题？ 公司所属行业和工作年限要求都对求职者有着不同的侧重点，现举例分析如下：(1) 从公司所属行业来看① 社交门户类，多考察大规模高并发场景的应用与架构能力；② O2O类，多考察综合能力；③ 互联网金融类，多考察逻辑能力与高可用、安全领域的经验。(2) 从工作年限上来看① 校招，考察基础知识和逻辑思维，以及培养潜力；② 初中级工程师，考察知识的广度和基础知识的应用；③ 高级或资深工程师，考察综合能力，如对基本原理的深入理解和对各种知识的灵活运用。 补充：针对面试官抛出的问题，回答时需要尽量发散扩展；建议在面试前对公司业务和岗位职责作针对性的准备，以提高面试成功率。 如何提升晋级？ 技术的更新迭代速度快，学习要系统，需要先建立一套知识体系或思维框架，然后再丰富完善其中细节。]]></content>
      <categories>
        <category>JAVA知识点梳理</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>职业发展</tag>
      </tags>
  </entry>
</search>
