<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[第2章| Java并发机制的底层实现原理]]></title>
    <url>%2F2019%2F07%2F29%2F%E7%AC%AC2%E7%AB%A0-Java%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[Java具有“一次编译，到处运行”的特性，而这与JVM(Java Virtual Machine, Java虚拟机)密不可分。因为.java后缀的代码到最后运行，需要先经过编译器编译为.class后缀的字节码，接着字节码被类加载器加载到JVM中，最后转变为0-1的汇编指令才能被CPU执行等这一系列过程。本章的宗旨为深入底层了解Java并发机制的实现原理。 volatile的应用 volatile的定义Java编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致地更新，线程应该确保通过排他锁单独获取这个变量。 volatile作用volatile是轻量级的synchronized，在多处理器开发中保证了共享变量的“可见性”（即一个线程修改一个共享变量时，另外一个线程能读到这个修改的指）。由于使用volatile不会引起线程切换上下文和调度，所以某种程度上使用volatile会比用synchronized的成本低。 volatile实现原则（1）Lock前缀指令会引起处理器缓存回写到内存（2）一个处理器的缓存回写到内存会导致其他处理器的缓存失效 优化volatie方法———追加字节优化因为大多数处理器的L1、L2、L3缓存的高速缓存行是64字节，不支持部分填充缓存行。所以处理器会把不满足64字节的节点读入到一个高速缓存行，这样会导致当一个处理器要修改时，64字节的高速缓存行都会被锁定。又由于缓存的一致性协议，会导致此时其他所有处理器的缓存行失效，从而无法进行操作，所以这将及其影响性能。但并不是盲目地每次都通过追加字节来优化volatie的使用，以下两种情况就不适用：（1）少部分缓存行不是64字节宽度的处理器；（2）不频繁地写共享变量：共享变量不被频繁写，意味着同时竞争的概率小，用锁的概率也就小。 扩展（1）CPU的术语定义 术语 对应英文名 术语解释 内存屏障 memory barriers 是一组处理器指令，用于实现对内存操作的顺序限制 缓冲行 cache line CPU告诉缓存中可以分配的最小存储单位。处理器填写缓存行时会加载整个缓存行，现代CPU需要执行几百次CPU指令 原子操作 atomic operation 不可中断的一个或一系列操作 缓存行填充 cache line fill 当处理器识别到从内存中读取操作数是可缓存的，处理器读取整个高速缓存行到适当的缓存（L1, L2, L3的或所有） 缓存命中 cache hit 如果进行高速缓存行填充操作的内存位置仍然是下次处理器访问的地址时，处理器从缓存中读取操作数，而不是从内存中读取 写命中 write hit 当处理器将操作数写回到一个内存缓存的区域时，它会首先检查这个缓存的内存地址是否在缓存行中，如果存在一个有效的缓存行，则处理器将这个操作数协会到缓存，而不是写到内存 &nbsp;&nbsp;&nbsp;&nbsp;（2）cpu、缓存、内存、硬盘的关系逻辑上将内存+缓存称为“内存储空间”，将硬盘称为“外存储空间”。由于cpu无法直接读写硬盘存储的数据，所以需要内存作为二者之间的桥梁，而有由于内存的读写速度与cpu处理速度相差较大，因此引入了缓存的概念，来匹配cpu与内存之间速度的差异，相应地存在一级、二级、三级缓存。 &nbsp;&nbsp;&nbsp;&nbsp;（3）缓存一致性协议每个处理器通过嗅探（一般指嗅探器，可以窃听网络上流经的数据包）在总线上传播的数据来检查自己缓存的值是否过期，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置为无效状态，当处理器对这个数据进行修改时，会重新从系统内存中读取数据到处理器缓存。 synchronized的实现原理与应用 Java SE 1.6前synchronized被称为重量级锁，1.6版本后对某些情况进行了优化。该节主要介绍1.6版本后引入的偏向锁和轻量级锁，以及锁的存储结构和升级过程。 Java中锁存在的三种形式： 对于普通同步方法，锁是当前实例对象 对于静态同步方法，锁是当前类的Class对象 对于同步方法块，锁是Synchronized括号里配置的对象 JVM中Synchronized实现原理JVM基于进入和退出Monitor对象来实现方法同步和代码块同步，代码块同步用monitorenter和monitorexit实现，尽管方法同步的实现用的是另一种方式，但也可以用这两条指令实现。 monitorenter和monitorexitmonitorenter指令是在编译后插入到同步代码块开始的地方，monitorexit则是插入到方法结束处和异常处。JVM中一个monitorenter必与一个monitorexit相对应，而且每个对象都有一个monitor。运行到monitorenter指令时，会尝试获取当前对象对应的monitor所有权，即尝试获得对象的锁。 Java对象头Java对象头里存储了synchronized用的锁，32位虚拟机中Java对象头的长度如下表所示： 长度 内容 说明 32/64bit Mark Word 存储对象的hashCode或锁信息等 32/64bit Class Metadata Address 存储到对象类型数据的指针 32/32bit Array length 数组的长度（如果当前对象是数据） 锁的升级与对比Java SE 1.6后锁有四种状态： 无锁状态 偏向锁状态 轻量级锁状态 重量级锁状态 锁的状态会随着竞争情况依次由上到下升级，同时锁可以升级但不能降级，这种策略保证了获得锁和释放锁的效率。 偏向锁研究发现大多数的锁总是由同一线程多次获得，所以为了降低线程获取锁的代价引入了偏向锁。 关闭偏向锁Java6/7中偏向锁默认是开启的，它在应用程序启动几秒后才激活，可通过JVM参数-XX:BiasedLockingStartupDelay=0来关闭延迟。如果可以确认所有的锁通常情况下处于竞争状态，就可以通过JVM参数关闭偏向锁:-XX:-UseBiasedLocking=false 轻量级锁 锁的优缺点对比 锁 优点 缺点 适用场景 偏向锁 加锁和解锁不需要额外的消耗，和执行非同步方法相比仅存在纳秒级的差距 如果线程间存在锁竞争，会带来额外的锁撤销消耗 适用于只有一个线程访问同步块场景 轻量级锁 竞争的线程不会阻塞，提高了程序的响应速度 如果始终得不到锁竞争的线程，使用自旋会消耗CPU 追求响应时间，同步块执行速度非常快 重量级锁 线程竞争不适用自旋 线程阻塞，响应时间缓慢 追求吞吐量，同步块执行速度较快 ### 原子操作的实现原理 1. 通过总线锁保证原子性 2. 通过缓存锁定保证原子性 两种不使用缓存锁定的情况 当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行(cache line)时，处理器会调用总线锁定； 处理器不支持缓存锁定 CAS实现原子操作的三大问题 ABA问题 循环时间长开销大 只能保证一个共享变量的原子操作]]></content>
      <categories>
        <category>Java并发编程的艺术</category>
      </categories>
      <tags>
        <tag>volatile</tag>
        <tag>synchronized</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu18.04 Chrome和firefox浏览器中字体异常变粗？]]></title>
    <url>%2F2019%2F07%2F27%2FUbuntu18-04-Chrome%E5%92%8Cfirefox%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E5%AD%97%E4%BD%93%E5%BC%82%E5%B8%B8%E5%8F%98%E7%B2%97%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[问题描述在安装好Ubuntu18.04 LTS后，正常使用谷歌浏览器和火狐浏览器，在浏览其他网页时并没有发现有异常的地方，直到在网页中使用Markdown语法的加粗显示时，才发现此时加粗文字与其他文字效果相同，并不能显示出强调效果。 由于是利用hexo搭建的博客，所以一度怀疑是不是Markdown的加粗效果未生效，此时进到简书博客内容界面，发现了以前用Markdown语法的加粗效果也未显示(参见下图)，而且像是整体都有了加粗效果。这下回过头发现知乎、腾讯新闻、网易新闻等常见页面字体都像是黑体，所以加粗效果才会没有比较，显示不出来。 解决办法通过搜索关键字Ubuntu18 Chrome 字体变粗后发现了，参考了一篇知乎文章——如何解决Chrome字体变粗的问题？，发现了页面中font-family属性。进而得知该属性规定元素的字体系列，可以把多个字体名称作为一个“回退”系统来保存。如果浏览器不支持第一个字体，则会尝试下一个。 由此开始查看简书博客中上图界面对应的font-family属性，情况如下： 再对应系统中已安装字体可以发现，Microsoft YaHei之前的字体都未安装，由font-family属性可知，这里直接采用微软雅黑作为了页面的字体展示样式，所以再用Markdown语法** **时，由于原本就是黑体，所以加粗了显示效果不明显或不显示。所以这里选择安装了Airal，PingFang SC等字体， Ubuntu18安装字体到/usr/share/fonts/ 下载获取要安装的字体文件，如.ttf或.ttc等 在/usr/share/fonts/目录下新建一个自定义文件夹 1sudo mkdir /usr/share/fonts/custom 将字体文件放入custom文件夹下，并修改custom文件夹权限 12sudo mv *.ttf /usr/share/fonts/custom/sudo chmod 744 -R /usr/share/fonts/custom/ 让字体文件生效 123sudo mkfontscale #创建可缩放字体索引文件sudo mkfontdir #在目录中给字体文件创建索引sudo fc-cache -fv #编译生成字体缓存文件 重启浏览器后再打开页面发现Markdown的加粗语法已经生效，如下图： 小结通过这次的问题，简单地了解了css中font-family属性的作用]]></content>
      <categories>
        <category>日常操作记录</category>
      </categories>
      <tags>
        <tag>Chrome</tag>
        <tag>font-family</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第1章| 并发编程的挑战]]></title>
    <url>%2F2019%2F07%2F24%2F%E7%AC%AC1%E7%AB%A0-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E6%8C%91%E6%88%98%2F</url>
    <content type="text"><![CDATA[不是启动越多的线程，程序就能最大限度地并发执行。并发编程通常会受到上下文切换、死锁、硬件和软件资源等问题的影响。 上下文切换 单核cpu通过为每个线程分配cpu时间片来实现多线程，时间片时长通常为几十毫秒。 上下文切换会影响到多线程的执行速度。 问题： 并发执行的代码是不是肯定比串行执行的快？回答： 不一定，因为多线程的创建和切换上下文也有开销，所以在循环次数较少时，耗时效果并不理想。通常需要百万级别以上，多线程的优势才能被体现出来。 上下文切换的开销会影响到整体的耗时，所以因尽量减少上下文切换，可采取以下策略： 无锁并发编程：多线程中减少使用锁的次数，从而减少竞争锁时带来上下文切换的次数，如将数据的ID按照Hash算法取模分段，不同线程处理不同段的数据； CAS算法：利用该算法更新数据，可不需加锁 使用最少线程：适量创建线程个数，减少不必要线程产生的等待时间 协程：在单线程中实现多任务的调度，并在单线程中维持多个任务见的切换，这样就没有多线程的切换。 死锁 死锁的概念当两个或两个以上的进程在执行过程中，双方都在等待对方停止运行，以获取系统资源，但是没有一方提前退出时，就称为死锁。 避免死锁的方法 避免一个线程同时获取多个锁 避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源 尝试使用定时锁，使用lock.tryLock(timeout)来替代使用内部锁机制 对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况。 资源限制的挑战 资源限制概念指在并发编程中，程序的执行速度受到计算机硬件或软件资源影响的情况。硬件资源限制有：带宽、硬盘读写、cpu处理速度等；软件资源限制有：数据库链接数和socket连接数等。 在资源限制情况下，原本将串行代码并发执行以此来加快执行时间，但这种情况下由于资源限制，导致代码仍只能串行执行，但是并发中加入了上下文切换和调度的时间，从而导致整体运行时间不减反增。 处理资源限制方法 硬件资源限制：由于是计算机资源受限，所以可以采用增加计算机个数的方法，如用集群并发执行程序。 软件资源限制：使用资源池复用资源，不使用资源池而频繁地创建销毁连接，会极大地浪费系统资源，增加响应耗时，影响系统性能。 问题总结 协程的概念？协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。没有生命周期。 JDK提供了哪些并发容器和工具类可以用来解决并发问题？java.util.concurrent及其子包，具体包含以下几个方面： 提供了几个非常有用的并发工具类，包括CountDownLatch、CyclicBarrier、Semaphore等，可以实现更加丰富的多线程操作。比如利用Semaphore作为资源控制器，限制同时进行工作的线程数量。 各种线程安全的容器，比如最常见的ConcurrentHashMap、有序的ConcurrentSkipListMap，或者通过类似快照机制，实现线程安全的动态数组CopyOnWriteArrayList等。 各种并发队列实现，如各种BlockingQueue实现，比较典型的ArrayBlockingQueue、SynchorousQueue或针对特定场景的PriorityBlockingQueue等。 强大的Executor框架，可以创建各种不同类型的线程池，调度任务运行等。绝大部分情况下，不再需要自己从头实现线程池和任务调度器。 思考 join 是什么join()方法是Thread类中的一个方法，方法的定义为等待该线程终止，底层通过wait()方法实现。更多内容可参考：What does this thread join code mean? vmstat 怎么用，参数怎么用，输出内容都指的是什么vmstat: 检测系统CPU/内存/磁盘输入输出状态等。 123456789101112vmstat [-a] [延迟 [总计检测次数]] &lt;==CPU/内存等信息vmstat [-fs] &lt;==内存相关vmstat [-S 单位] &lt;==设置显示数据的单位vmstat [-d] &lt;==与磁盘相关vmstat [-p 分区] &lt;==与磁盘相关参数：-a : 使用 inactive/active（活跃与否）替代 buffer/cache的内存输出信息；-f : 开机到目前为止系统复制（fork）的进程数；-s : 将一些事件(开机到目前为止)导致的内存变化情况列表说明-S : 后面可以接单位，让显示的数据有单位。例如 K/M 取代 bytes 的容量；-d : 列出磁盘的读写总量统计表-p : 后面列出分区，可显示该分区的读写总量统计表 示例： vmstat 1 3：统计目前主机CPU状态，每秒一次，共计三次！各字段说明如下： 内存栏位 (procs) 的项目分别为：r ：等待运行中的程序数量；b：不可被唤醒的程序数量。这两个项目越多，代表系统越忙碌 (因为系统太忙，所以很多程序就无法被运行或一直在等待而无法被唤醒之故)。 内存栏位 (memory) 项目分别为：swpd：虚拟内存被使用的容量；free：未被使用的内存容量；buff：用于缓冲内存；cache：用于高速缓存。 这部份则与 free 是相同的。 内存置换空间 (swap) 的项目分别为：si：由磁碟中将程序取出的量；so：由于内存不足而将没用到的程序写入到磁碟的 swap 的容量。 如果 si/so 的数值太大，表示内存内的数据常常得在磁碟与主内存之间传来传去，系统效能会很差！ 磁碟读写 (io) 的项目分别为：bi：由磁碟写入的区块数量；bo：写入到磁碟去的区块数量。如果这部份的值越高，代表系统的 I/O 非常忙碌！ 系统 (system) 的项目分别为：in：每秒被中断的程序次数；cs：每秒钟进行的事件切换次数；这两个数值越大，代表系统与周边设备的沟通非常频繁！ 这些周边设备当然包括磁碟、网络卡、时间钟等。 CPU 的项目分别为：us：非核心层的 CPU 使用状态；sy：核心层所使用的 CPU 状态；id：闲置的状态； wa：等待 I/O 所耗费的 CPU 状态；st：被虚拟机器 (virtual machine) 所盗用的 CPU 使用状态 (2.6.11 以后才支持)。 cas 是什么CAS（比较与交换，Compare and swap） 是一种有名的无锁算法，维护三个变量值，一个是内存值V，一个是期望的旧的值A，一个是要更新的值B。更新一个变量的时候，只有当预期值A与内存V中的值相等的时候，才会执行更新操作，把内存V的值改为B。当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。从思想上来说，synchronized属于悲观锁，悲观地认为程序中的并发情况严重，所以只能在一个线程获取到锁后，其他线程被挂起等待；CAS属于乐观锁，乐观地认为程序中的并发情况不那么严重，所以让线程不断去重试更新。 awk 是什么，怎么用awk 也是一个非常好用的数据处理工具，awk倾向于一行当中分成数个『栏位』来处理。而默认的『栏位的分隔符号为 “空白键” 或 “[tab]键” 』！awk 通常运行的模式是这样的： 12awk '条件类型1&#123;动作1&#125; 条件类型2&#123;动作2&#125; ...' filenameawk后面接两个单引号并加上大括号 &#123;&#125; 来配置想要对数据进行的处理动作。 示例:e.g. 输出poem中第2行至第6行的第2列与第4列内容以及第1列乘10结果，中间以#符分割（提示：NR为当前处理行的行号） 1234567891011121314151617cat poem******结果******1 --------------------------2 The Noon Balloon3 Will be leaving soon4 For the sun or the moon.5 And wherever it goes,6 It will get there too soon.7 --------------------------awk 'NR&gt;=2 &amp;&amp; NR&lt;=6 &#123;print $2"#"$4"#"$1*10&#125;' poem******结果******The#Balloon#20Will#leaving#30For#sun#40And#it#50It#get#60 更多内容参见：Linux awk 命令 linux 管道是什么鬼管道是Linux中很重要的一种通信方式,是把一个程序的输出直接连接到另一个程序的输入,常说的管道多是指无名管道,无名管道只能用于具有亲缘关系的进程之间，这是它与有名管道的最大区别。有名管道叫named pipe或者FIFO(先进先出)，可以用函数mkfifo()创建。 jstack 命令怎么用jstack用于打印出给定的java进程ID或core file或远程调试服务的Java堆栈信息，命令格式如下： 12345678910$jstack [ option ] pid$jstack [ option ] executable core$jstack [ option ] [server-id@]remote-hostname-or-IP参数说明:pid: java应用程序的进程号,一般可以通过jps来获得;executable:产生core dump的java可执行程序;core:打印出的core文件;remote-hostname-or-ip:远程debug服务器的名称或IP;server-id: 唯一id,假如一台主机上多个远程debug服务; 官方文档参见：jstack TIMED_WAITING 是什么意思一个线程在一个特定的等待时间内等待另一个线程完成一个动作会在这个状态]]></content>
      <categories>
        <category>Java并发编程的艺术</category>
      </categories>
      <tags>
        <tag>上下文切换</tag>
        <tag>死锁</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql02| 从SQL更新语句看mysql日志系统]]></title>
    <url>%2F2019%2F05%2F12%2FMysql02-%E4%BB%8ESQL%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E7%9C%8Bmysql%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[MySQL 可以恢复到半个月内任意一秒的状态，这是为什么？ mysql的更新语句与查询语句大体相同，但多了两个日志模块即redo log（重做日志）和binlog（归档日志） 一、redo log和binlog1、redo log模块（存储引擎层日志） WAL技术（Write-Ahead Logging）是InnoDB引擎先将“更新”写到redo log中并更新内存，这时候就算更新完毕了，等计算机“空闲”时再写入硬盘当中。 其中redo log是有固定大小的，等被写满时就不得不写入硬盘中了。也正因为有redo log的存在，所以在mysql发生异常重启后，InnoDB就可以记录不丢失，该能力被称为crash-safe。 2、binlog日志模块（server层日志）3、两个日志模块联系与差异 mysql5.5.5以前默认使用自带的MyISAM引擎，该引擎没有crash-safe能力，只能依靠MyISAM进行归档；在 5.5.5 版本后使用InnoDB作为默认存储引擎。 差异处： redo log是InnoDB特有的，而binlog位于server层，所有引擎都可以使用； redo log是物理日志，记录了在实际物理位置进行的操作；binlog是逻辑日志，记录的是执行语句的原始逻辑； redo log是循环写，固定大小会被写完；binlog是追加写，写到一定大小切换到下一个，不覆盖以往内容。 二、update语句执行流程注：下图中浅色在InnoDB中进行，深色在执行器中完成。由上图可知，InnoDB中的操作被分成了两阶段提交，之所以要这样做，是因为只有一步的话，会导致一句日志回复的数据库状态与原数据库状态不同，这样在数据库发生崩溃和扩容时都带来巨大问题。这样做了可以保证redo log和binlog的逻辑一致。 tips:可以将mysql参数innodb_flush_log_at_trx_commit和sync_binlog这两个参数设为1，这样能保证数据库异常重启后物理日志和逻辑日志都不会丢失，因为已经被写到磁盘当中了。]]></content>
      <categories>
        <category>Mysql学习实录</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql01| 从SQL语句执行过程看mysql架构]]></title>
    <url>%2F2019%2F05%2F12%2FMysql01-%E4%BB%8ESQL%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E7%9C%8Bmysql%E6%9E%B6%E6%9E%84%2F</url>
    <content type="text"><![CDATA[MySQL的框架有几个组件, 各是什么作用? 连接器：和客户端建立连接、获取权限、维持和管理连接 查询缓存：查看历史记录中是否存在本次查询结果，有的话直接返回结果，否则继续向下执行。由于查询失效频繁，所以不推荐使用查询缓存（mysql8中已删除查询缓存模块）。 分析器：进行词法分析和语法分析，前者要将各个字符串对应到关键字、表、字段名等，后者将判断输入语句是否满足mysql语法。 优化器：决定使用哪个索引，或决定在join语句中使用哪个表作为驱动表。 执行器：验证完权限后，执行SQL语句，使用表存储引擎提供的接口。]]></content>
      <categories>
        <category>Mysql学习实录</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql34| Join用法记录]]></title>
    <url>%2F2019%2F05%2F12%2FMysql34-Join%E7%94%A8%E6%B3%95%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[如果可以使用被驱动表的索引，join要优于单表查询 ； 不能使用被驱动表的索引，只能用Block Nested-Loop join算法，这样的SQL语句应当弃用； 在使用join时，应当让运行中数据量小的表作为驱动表。]]></content>
      <categories>
        <category>Mysql学习实录</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>Join</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[翻译| Github: Authorizing OAuth Apps]]></title>
    <url>%2F2019%2F05%2F08%2F%E7%BF%BB%E8%AF%91-Github-Authorizing-OAuth-Apps%2F</url>
    <content type="text"><![CDATA[tips：本文为github-API关于授权账号登录其他网站开发文档的个人中文翻译，官网文档对应：Authorizing OAuth Apps 授权OAuth应用程序你可以授权github账号登录其他网站 Github的授权实现支持标准授权码授权类型。你可以用下面描述的web应用流程去获取授权code，然后用code去交换获取token。（不支持隐式授权类型） 遇到问题可以参见下面的文章： 认证请求错误汇总 OAuth应用获取token请求错误汇总 Web应用授权流程 Note: 如果建立了一个Github应用，仍然可以使用OAuth web应用流程，不过二者在方案上还是有区别的。更多内容可见关于Github应用认证和授权用户 应用授权用户步骤如下： 用户重定向去请求Github认证 用户从github重定向回到你的web 你的应用通过access token获取到了API 1. 请求Github认证1GET https://github.com/login/oauth/authorize 当你的Github应用指定了login参数，它会给用户一个特定的账户去登录和授权你的应用。 参数|Name|Type|说明||:-:|:-:|:-||client_id|string|必需有。当你注册Github授权应用时产生的client ID||redirect_uri|string|Github授权后返回你的应用地址。更多细节参考redirect urls||login|string|意味着一个用来登录和授权应用的特定账户||scope|string|以空格分隔的scope列表。如果此处为空，scope默认对用户是一个空的列表，即没有对应用授权任何scope，在OAuth授权页面的scopes列表中也不会有该用户。对应地，这一步工作流程将会自动完成授权应用的用户scope集。例如，一个用户已经执行web授权流程两次，用userscope和reposcope各授权了一次，那么第三次web流程没有提供scope时也会受到前面userscope和reposcope得到的token。||state|string|一个不可预计的随机字符串，被用作为保护伪造跨域请求攻击。||allow_signup|string|无论用户是否认证，都将被提供一个选项在OAuth流程中是否要注册Github。默认是true，在政策禁止注册下可使用false。 2. 用户从Github重定向回到你的网站如果接受了你的请求，Github会重定向回到你的网站，并携带一个临时的code在code参数中，还在state参数中携带了上一步你提供的state。临时的code将在10分钟后失效。如果states不匹配，那么第三方将会创建请求，并且你需要中断当前操作。 用code取交换获取access token: 1POST https://github.com/login/oauth/access_token 参数|Name|Type|说明||:-:|:-:|-||client_id|string|必需有。当你注册Github授权应用时产生的client ID||client_secret|string|必需有。当你注册Github授权应用时产生的client secret||code|string|必需有。你收到的code是对应step1中的||redirect_uri|string|是你应用中的URL，这个地址用作用户授权返回地址||state|string|step1中你提供的随机字符串| 响应通常，得到的响应一般为下面这种形式： 1access_token=e72e16c7e42f292c6912e7710c838347ae178b4a&amp;token_type=bearer 你也有可能因为Accpt header形式的不同接收到不同的内容 123456789Accept: application/json&#123;"access_token":"e72e16c7e42f292c6912e7710c838347ae178b4a", "scope":"repo,gist", "token_type":"bearer"&#125;Accept: application/xml&lt;OAuth&gt; &lt;token_type&gt;bearer&lt;/token_type&gt; &lt;scope&gt;repo,gist&lt;/scope&gt; &lt;access_token&gt;e72e16c7e42f292c6912e7710c838347ae178b4a&lt;/access_token&gt;&lt;/OAuth&gt; 3. 利用access token去获取APIaccess token可以让你以用户的身份请求API 12Authorization: token OAUTH-TOKENGET https://api.github.com/user 例如，你可以像下面这样用curl设置header： 1curl -H "Authorization: token OAUTH-TOKEN" https://api.github.com/user 非Web应用授权流程基于Basic Authentication利用接口去创建OAuth2 token。通过这种方法，用户名和密码不需要被永久存储，而且用户可以在任何时候撤销access。 Note: 当使用非Web应用授权流程创建OAuth2 token时，如果你或你的用户是双重认证的话，应确保理解双重认证机制 Redirect URLsredirect_uri参数是可选的。如果省略，Github将重定向用户到callback URL，这一地址被配置在了OAuth Application settings部分。如果提供了，redirect URL的主机和端口必须准确匹配callback URL。redirect URL路径必须引用callback URL的子目录。 123456789CALLBACK: http://example.com/pathGOOD: http://example.com/pathGOOD: http://example.com/path/subdir/otherBAD: http://example.com/barBAD: http://example.com/BAD: http://example.com:8080/pathBAD: http://oauth.example.com:8080/pathBAD: http://example.org 为OAuth应用创建多个token你可以为user/application/scope组合创建多个token用作特定用途。 如果你的OAuth应用支持使用Github登录，并且一个工作流只需要用户的基本信息，另一个工作流可能需要获取用户私有资料，这样创建多个token是可行的。使用多个token，你的OAuth应用就可以根据不同用途执行不同web工作流，只需要请求scope需要的。如果一个用户仅使用你的应用去登录，他们就不会去授权你的OAuth应用去获取他们的私有资料。 每次的user/application/scope组合发布的token数量有限定，如果你的应用对其中一个限定请求了足够多的token，那么位于同一scope的旧token就会停止工作。 Warning: 撤销OAuth应用的所有许可会删除代表应用产生的表征用户的所有SSH keys，其中包括deploy keys。 重定向用户去检查他们的access你链接到OAuth应用的授权信息，用户就可以检查和取消他们的应用授权。 为了建立这个链接，需要注册OAuth应用时从Github接收到的client_id。 1https://github.com/settings/connections/applications/:client_id tips: 了解更多关于OAuth应用访问用户详见”Discovering resources for a user.”]]></content>
      <categories>
        <category>码农笔记</category>
      </categories>
      <tags>
        <tag>文档翻译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[03| 计算机网络相关知识]]></title>
    <url>%2F2019%2F04%2F09%2F03-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[知识点汇总 1. 4/7层网络模型（&hearts;&hearts;&hearts;）[^1] OSI七层 TCP/IP四层 网络协议 应用层（Application） 应用层 HTTP、TFTP, FTP, NFS, WAIS、SMTP 表示层（Presentation） 应用层 Telnet, Rlogin, SNMP, Gopher 会话层（Session） 应用层 SMTP, DNS 传输层（Transport） 传输层 TCP, UDP 网络层（Network） 网络层 IP, ICMP, ARP, RARP, AKP, UUCP 数据链路层（Data Link） 数据链路层 FDDI, Ethernet, Arpanet, PDN, SLIP, PPP 物理层（Physical） 数据链路层 IEEE 802.1A, IEEE 802.2到IEEE 802.11 2. TCP协议2.1 三次握手建连2.2 四次挥手断连2.3 报文状态标志与连接状态[^2]LISTEN：侦听来自远方的TCP端口的连接请求 SYN-SENT：再发送连接请求后等待匹配的连接请求 SYN-RECEIVED：再收到和发送一个连接请求后等待对方对连接请求的确认 ESTABLISHED：代表一个打开的连接 FIN-WAIT-1：等待远程TCP连接中断请求，或先前的连接中断请求的确认 FIN-WAIT-2：从远程TCP等待连接中断请求 CLOSE-WAIT：等待从本地用户发来的连接中断请求 CLOSING：等待远程TCP对连接中断的确认 LAST-ACK：等待原来的发向远程TCP的连接中断请求的确认 TIME-WAIT：等待足够的时间以确保远程TCP接收到连接中断请求的确认 CLOSED：没有任何连接状态 2.4 Nagel算法与ACK延迟2.5 Keepalive2.6 滑动窗口与流量控制[^1]:好就分享. OSI七层协议模型、TCP/IP四层模型学习笔记[^2]:mei922. TCP连接状态详解]]></content>
      <categories>
        <category>JAVA知识点梳理</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常用命令]]></title>
    <url>%2F2019%2F04%2F01%2FLinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[此部分主要考察java从业者的线上问题排查能力，现基于CentOS release 6.5 (Final)简要介绍如下6个命令[^1]，期间用poem文件举例。推荐查询linux命令的两个网址Linux 命令大全 | 菜鸟教程Linux命令大全(手册)。 123456789cat poem******结果******1 --------------------------2 The Noon Balloon3 Will be leaving soon4 For the sun or the moon.5 And wherever it goes,6 It will get there too soon.7 -------------------------- awk命令：好用的数据处理工具（默认分隔符：空格或tab）sed常用作一整行的处理，awk则倾向于将一行分成数个“字段”处理，适合小型数据处理。 语法：awk ‘条件类型1 {动作1} 条件类型2 {动作2}…’ filenamee.g. 输出poem中第2行至第6行的第2列与第4列内容以及第1列乘10结果，中间以#符分割（提示：NR为当前处理行的行号） 1234567awk &apos;NR&gt;=2 &amp;&amp; NR&lt;=6 &#123;print $2&quot;#&quot;$4&quot;#&quot;$1*10&#125;&apos; poem******结果******The#Balloon#20Will#leaving#30For#sun#40And#it#50It#get#60 top命令：动态查看进程变化 语法：top [-d 数字] | top [-bnp]-d 页面刷新时间间隔描述，本次所用系统默认3秒-b 以批次的形式展现-n 执行几次后停止-p 查看进程号为p的进程动态 e.g. 每隔3秒批次查看进程号为1673的进程3次，然后结束。top -d 3 -b -n 3 -p 1673 netstat命令：跟踪网络 语法：netstat -[atunlp]-a 显示系统所有连接、监听、Socket-t 列出tcp网络数据包的数据-u 列出udp网络数据包的数据-n 不列出进程的服务名称，以端口号显示-l 列出正在监听的服务-p 列出进程号为PID的进程e.g. 累出目前系统已经新建的网络连接与Unix Socket状态netstat 123456789101112131415Active Internet connections (w/o servers)Proto Recv-Q Send-Q Local Address Foreign Address State tcp 0 1 node4:42278 node1:intu-ec-svcdisc SYN_SENT tcp 0 1 node4:59492 node2:intu-ec-svcdisc SYN_SENT tcp 0 0 node4:ssh 192.168.226.1:56589 ESTABLISHED tcp 0 132 node4:ssh 192.168.226.1:53859 ESTABLISHED tcp 0 0 node4:8031 node4:32834 ESTABLISHED tcp 0 1 node4:44307 node1:eforward SYN_SENT tcp 0 0 node4:32834 node4:8031 ESTABLISHED Active UNIX domain sockets (w/o servers)Proto RefCnt Flags Type State I-Node Pathunix 14 [ ] DGRAM 11626 /dev/logunix 2 [ ] DGRAM 9228 @/org/kernel/udev/udevdunix 2 [ ] DGRAM 12430 @/org/freedesktop/hal/udev_event…（省略）… grep命令：分析一行数据，后边常跟正则表达式 语法：grep [-acinv] [–color=auto] ‘查找字符串’ filename-a 将binary文件以text文件方式查找数据-c 计算找到’查找字符串’的次数-i 忽略大小写的不同-n 输出行号-v 输出没有’查找字符串’的那一行e.g. 输出poem包含’l’字符的几行，顺带输出行号grep -n &#39;l&#39; poem 1232:2 The Noon Balloon3:3 Will be leaving soon6:6 It will get there too soon. less命令：一页一页翻动（往前往后翻）由于poem文件长度较短，不便演示 tail命令：取出后面几行 语法：tail -ne.g. 显示poem后两行 1234tail -n 2 poem******结果******6 It will get there too soon.7 -------------------------- [^1]:鸟哥. 鸟哥的Linux私房菜[M]. 北京: 人民邮电出版社, 2016.]]></content>
      <categories>
        <category>码农笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[继承Thread类和实现Runnable接口法的异同]]></title>
    <url>%2F2019%2F03%2F31%2F%E7%BB%A7%E6%89%BFThread%E7%B1%BB%E5%92%8C%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3%E6%B3%95%E7%9A%84%E5%BC%82%E5%90%8C%2F</url>
    <content type="text"><![CDATA[导语：在java中实现多线程的方法有两种：继承Thread类和实现Runnable接口。在使用这两种方法创建多线程类时有什么不同呢？下面作简要分析。 一、继承Thread类法1.1. 这里先给出一个小demo，实现代码如下： 1234567891011121314151617181920212223class MyThread extends Thread &#123; private String name; public MyThread(String name) &#123; this.name = name; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) System.out.println(Thread.currentThread().getName() + &quot;+&quot; + name + &quot;+运行了+&quot; + (i + 1) + &quot;次&quot;); &#125;&#125;public class ThreadDemo1 &#123; public static void main(String[] args) &#123; MyThread mt_A = new MyThread(&quot;线程A&quot;); MyThread mt_B = new MyThread(&quot;线程B&quot;); System.out.println(&quot;当前线程为：&quot; + Thread.currentThread().getName()); mt_A.start(); mt_B.start(); &#125;&#125; 运行结果（某次）： 123456789101112131415161718192021当前线程为：mainThread-1+线程B+运行了+1次Thread-0+线程A+运行了+1次Thread-1+线程B+运行了+2次Thread-0+线程A+运行了+2次Thread-1+线程B+运行了+3次Thread-0+线程A+运行了+3次Thread-1+线程B+运行了+4次Thread-0+线程A+运行了+4次Thread-1+线程B+运行了+5次Thread-0+线程A+运行了+5次Thread-1+线程B+运行了+6次Thread-0+线程A+运行了+6次Thread-1+线程B+运行了+7次Thread-0+线程A+运行了+7次Thread-1+线程B+运行了+8次Thread-0+线程A+运行了+8次Thread-1+线程B+运行了+9次Thread-0+线程A+运行了+9次Thread-1+线程B+运行了+10次Thread-0+线程A+运行了+10次 从运行结果可以看出，开启了两个新线程Thread-0和Thread-1，两个线程互相抢占资源完成了打印操作，实现了多线程操作！ 1.2. 为什么用start()启动线程而不是用run()方法？ 因为线程的运行需要本地操作系统的支持，先分别来看看start()和run()方法的源码。 1234567891011121314151617181920/*start()方法源码*/ public synchronized void start() &#123; if (threadStatus != 0) //如果当前线程不处于就绪状态，启动时就报错 throw new IllegalThreadStateException(); group.add(this); boolean started = false; try &#123; start0(); started = true; &#125; finally &#123; try &#123; if (!started) &#123; group.threadStartFailed(this); &#125; &#125; catch (Throwable ignore) &#123; &#125; &#125; &#125; private native void start0(); 在上面代码中出现了关键字native，表明了start0()是一个本地方法，说明start0()方法的运行需要本地操作系统的支持。 1234567/*run()方法源码*/ @Override public void run() &#123; if (target != null) &#123; target.run(); &#125; &#125; （1）从上面两处代码可以看出： start()方法最后是由start0()方法完成，它会新运行一个线程，新线程会调用run()方法，且start()方法不能被重复调用[1]，否则会抛出IllegalThreadStateException异常。 run()方法同一般成员方法一样，可以被重复调用。单独调用run()的时不会启动新线程，而是继续在当前线程中执行run()。为了验证run()方法不会启动新线程，可以将1.小demo中的mt_A.start();mt_B.start();改为mt_A.run();mt_B.runt();运行结果（每次相同）：123456789101112131415161718192021当前线程为：mainmain+线程A+运行了+1次main+线程A+运行了+2次main+线程A+运行了+3次main+线程A+运行了+4次main+线程A+运行了+5次main+线程A+运行了+6次main+线程A+运行了+7次main+线程A+运行了+8次main+线程A+运行了+9次main+线程A+运行了+10次main+线程B+运行了+1次main+线程B+运行了+2次main+线程B+运行了+3次main+线程B+运行了+4次main+线程B+运行了+5次main+线程B+运行了+6次main+线程B+运行了+7次main+线程B+运行了+8次main+线程B+运行了+9次main+线程B+运行了+10次 从执行结果可以看出，上述字符串的打印都是在主线程中完成的，未开启新线程，并且打印是按照先A后B的顺序执行的！ 二、实现Runnable接口法2.1. 同样这里给出此方法实现的小demo，代码如下： 123456789101112131415161718192021class MyRunnable implements Runnable &#123; private int ticket = 10; @Override public void run() &#123; for (int i = 0; i &lt; 50; i++) &#123; if (ticket &gt; 0) &#123; System.out.println(Thread.currentThread().getName() + &quot;+sell ticket:&quot; + ticket--); &#125; &#125; &#125;&#125;public class ThreadDemo2 &#123; public static void main(String[] args) &#123; MyRunnable my = new MyRunnable(); new Thread(my).start(); new Thread(my).start(); new Thread(my).start(); &#125;&#125; 运行结果如下： 12345678910Thread-1+sell ticket:10Thread-2+sell ticket:8Thread-0+sell ticket:9Thread-2+sell ticket:6Thread-1+sell ticket:7Thread-2+sell ticket:4Thread-2+sell ticket:2Thread-2+sell ticket:1Thread-0+sell ticket:5Thread-1+sell ticket:3 由结果可知使用Runnable接口的方式，完成了买票的业务。即用3个线程一块进行卖票，每张票只卖了一次，符合实际情况。 2.2. 用继承Thread类的方法执行卖业务时，就会发现行不通，具体情况如下： 12345678910111213141516171819class MyRunnable extends Thread &#123; private int ticket = 10; @Override public void run() &#123; for (int i = 0; i &lt; 50; i++) &#123; if (ticket &gt; 0) &#123; System.out.println(Thread.currentThread().getName() + &quot;+sell ticket:&quot; + ticket--); &#125; &#125; &#125;&#125;public class ThreadDemo2 &#123; public static void main(String[] args) &#123; new MyRunnable().start(); new MyRunnable().start(); new MyRunnable().start(); &#125;&#125; 运行结果如下 123456789101112131415161718192021222324252627282930Thread-0+sell ticket:10Thread-1+sell ticket:10Thread-1+sell ticket:9Thread-0+sell ticket:9Thread-1+sell ticket:8Thread-2+sell ticket:10Thread-1+sell ticket:7Thread-0+sell ticket:8Thread-1+sell ticket:6Thread-2+sell ticket:9Thread-1+sell ticket:5Thread-0+sell ticket:7Thread-1+sell ticket:4Thread-1+sell ticket:3Thread-1+sell ticket:2Thread-1+sell ticket:1Thread-2+sell ticket:8Thread-0+sell ticket:6Thread-2+sell ticket:7Thread-0+sell ticket:5Thread-2+sell ticket:6Thread-0+sell ticket:4Thread-2+sell ticket:5Thread-0+sell ticket:3Thread-2+sell ticket:4Thread-0+sell ticket:2Thread-2+sell ticket:3Thread-0+sell ticket:1Thread-2+sell ticket:2Thread-2+sell ticket:1 由运行结果可知，此处的三个线程各卖了10张票，与实际情况不符。 三、小结 Thread类也实现了Runnable接口，应尽量使用实现Runnable的方式，因为实现Runnable接口的方式比继承Thread类方法多以下优势：① 适合多个相同程序代码的线程去处理同一资源；② 避免了Java单继承带来的局限性；③ 增强了程序的健壮性，代码能被多个线程共享，代码与数据是独立的。 [1]:skywang12345. Java多线程系列–“基础篇”03之 Thread中start()和run()的区别]]></content>
      <categories>
        <category>码农笔记</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[02| 操作系统相关知识]]></title>
    <url>%2F2019%2F03%2F29%2F02-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[知识点汇总 操作系统部分知识有助于对服务问题进行排查定位，主要考察了解和应用，在面试中所占比较小。 1. 进程与线程（&hearts;&hearts;&hearts;）1.1 进程与线程之间的区别与联系？ 进程，是系统资源分配的最小单位，使用独立的数据空间 线程，是程序执行的最小单位，共享进程的数据空间 1.2 线程的状态线程一般包含5种状态[^1]：创建、就绪、运行、阻塞和终止。有的会把线程状态分为6种[^2]：初始、运行、阻塞、等待、超时等待和终止，这种的将原来5种状态中的就绪和运行统称为运行，把原来阻塞细分为了阻塞、等待、超时等待三种。这样-1+2就相当于多增加了1种状态，这里还是采用经典的5种线程状态说法，可以用图1来表示5种线程状态之间的关系。 创建状态继承Thread类和实现Runnable接口都可创建一个线程，此时的线程处于创建状态。（这里扩展一点——「多线程」继承Thread类和实现Runnable接口法的异同） 就绪状态当start()方法执行后，线程就进入了就绪状态。这时线程就处在了线程队列当中，等待CPU资源，代表其已经具备运行的资格。 运行状态当处于就绪状态的线程获得CPU资源时，该线程就进入了运行状态，此时run()方法中定义的操作将被执行。 阻塞状态运行状态的线程由于某些原因放弃了对CPU的使用权，这时候的线程就进入了阻塞状态，当引起阻塞的原因被解除时，线程才重新可以进入就绪状态。一般阻塞状态可以分为以下三种[^3]：（1）等待阻塞：执行wait()方法，该线程会释放占用的所有资源，JVM会把该线程放入“等待池”中。进入这个状态后，是不能自动唤醒的，必须依靠其他线程调用notify()或notifyAll()方法才能被唤醒；（2）同步阻塞：在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入“锁池”中，等待其他线程释放同步锁。（3）其他阻塞：执行sleep()或join()方法，或者发出了耗时的输入/输出请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者输入/输出处理完毕时，线程重新转入就绪状态。 终止状态线程的run()方法结束自然死亡或未捕获的异常导致run()方法终止，都会让该线程进入终止状态也就不具备继续运行能力了。判断线程是否终止，可用isAlive()方法。 1.3 线程调度（调度算法）[^4]在分析各种调度算法前，先简要了解一下分时系统与实时系统[^5]（典型的分时系统有UNIX和Linux，而对于windows，严格上说它的本质应该是多种集合的操作系统，它在运行过程中，根据不同的进程会有实时响应和分时响应，部分功能中，它也可以实现分布式操作。）。简单来说分时系统和实时系统都具备多路性（能为多个终端提供服务）和独立性（每个终端之间互不干扰），在及时性方面分时系统考虑的时间是在人可接受的范围内，而实时系统由于军事、工业、多媒体等特定业务的执行需要将时间控制在秒级、百毫秒级直至毫秒级甚至0.1毫秒；在交互性方面，分时系统具备该特性不必说，而实时信息处理系统具备的交互性也仅限于特定的服务程序；至于可靠性，实时系统此方面的要求要比分时系统高的多。 时间片轮转调度（Round Robin, RR）CPU为让每个线程看起来像在并行执行而分配出一个线程运行的时长，也就是时间片。每个就绪状态的线程在排队队列中将按时间片长依次循环执行，直至所有线程运行完毕。 先来先服务调度（First Come First Serve, FCFS）该调度方法仅考虑就绪状态的线程在排队队列中的先后顺序，不考虑其他因素，按照从队首到队尾的顺序依次执行每个线程，只有当该线程运行完毕或因其他原因被阻塞时才运行下一个线程。这种调度简单易行，是一种非抢占式调度策略。比较有利于长作业，而不利于短作业；有利于CPU繁忙的作业，而不利于I/O繁忙的作业。[^6] 优先级调度（Task Switching, TS）[^7][^8][^9]可以通过setPriority()方法来设定线程的优先级，优先级有10个梯度（1~10），即（MIN_PRIORITY【最低1级】—-&gt;……—-&gt;NORM_PRIORITY【普通5级】……—-&gt;MAX_PRIORITY【最高10级】）。处于就绪状态的两个线程，高优先级的线程比低优先级的线程具有更大的概率被CPU执行。至于为什么优先级高的线程不一定先执行，可参见[^10]。 多级反馈队列调度（Multilevel Feedback Queue Scheduling, MFQS）[^11]UNIX操作系统采取的便是这种调度算法。 NOTE1：假设有三个待调度的队列Q1、Q2和Q3，优先级依次递减。进程在进入待调度的队列等待时，首先进入优先级最高的Q1等待。 NOTE2：首先调度优先级高的队列中的进程。若高优先级中队列中已没有调度的进程，则调度次优先级队列中的进程。NOTE3：对于同一个队列中的各个进程，按照时间片轮转法调度。比如Q1队列的时间片为N，那么Q1中的作业在经历了N个时间片后若还没有完成，则进入Q2队列等待，若Q2的时间片用完后作业还不能完成，一直进入下一级队列Q3，直至完成。 NOTE4：在低优先级的队列中的进程在运行时，又有新作业达到最高优先级队列，那么在运行完这个时间片后，CPU马上分配给新到达的作业（抢占式）。 高响应比优先调度（Highest Response Ratio Next， HRRN）该调度策略既考虑作业的执行时间也考虑作业的等待时间，综合了先来先服务和最短作业优先两种算法的特点。但每次调度之前都要计算响应比，这也增加了系统开销，响应比公式定义如下： 响应比 =（等待时间+要求服务时间）/ 要求服务时间=1+等待时间/要求服务时间，可以看出响应比是大于1的。由响应比公式可知：(1) 如果线程的等待时间相同，则线程要求服务的时间愈短，其优先级愈高，因此该调度类似于短作业优先调度；(2) 如果线程要求服务的时间相同，则线程等待时间愈短，其优先级愈高，因此该调度类似于先来先服务调度；(3) 对于要求服务时间长的进程，进程的优先级可以随等待时间的增加而提高，因此也能随着优先级的提高得到服务。 1.4 线程切换步骤[^12] 多线程不一定就比单线程程序跑的快，因为多线程应用程序会带来额外的开销和竞争问题，可能会拖慢系统的执行速度。这些因素包括：对IO设备的竞争，对锁的竞争，以及CPU对线程执行上下文的频繁切换等。 线程的上下文一般指包括cpu的寄存器和程序计数器在某一时间点的内容等 线程的上下文切换与切换代价当 CPU 从执行一个线程切换到执行另外一个线程的时候，它需要先存储当前线程的本地的数据，程序指针等，然后载入另一个线程的本地数据，程序指针等，最后才开始执行。这种切换称为“上下文切换”(“context switch”)。CPU 会在一个上下文中执行一个线程，然后切换到另外一个上下文中执行另外一个线程。 线程在运行的时候除了需要从计算机里面获得【CPU资源】，还需要一些【内存】来维持它本地的【堆栈】，还需要占用操作系统中一些资源来【管理线程】。 1.4 Linux下的进程间通信（InterProcess Communication, IPC）面试中间件研发时常考察，了解以下6种进程间通信的相关原理[^13] 共享内存（适用于进程间数据共享场景） UnixSocket（适用于进程间数据交换场景） MessageQueue消息队列（适用于进程间数据交换场景） Pipe管道 Signal Semaphone信号量 1.5 协程 （1）协程又称为“微线程”，是一种用户态的轻量级线程（协程的调度完全由用户控制）。协程拥有自己的寄存器上下文和栈，调度切换时直接操作栈而基本没有内核切换的开销，所以其切换的代价要比线程上下文切换小很多，另外它可以不加锁的访问全局变量。（2）java的第三方协程框架，如Kilim和quasar。 2. Linux常用命令3. 死锁 两个线程都在等待对方先完成，造成了程序的停滞，一般程序的死锁都是在程序运行时出现的。 4. 内存分页管理与SwapLinux中关于swap、虚拟内存和page的区别 5. 任务队列与CPU Load任务队列，消息队列和rpc的区别是什么？CPU负载和 CPU使用率 6. 知识点扩展（了解）6.1 内存屏障 内存屏障，也称内存栅栏，内存栅障，屏障指令等， 是一类同步屏障指令，是CPU或编译器在对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作。 6.2 指令乱序（转）CPU乱序执行原理 6.3 CPU亲和性（affinity）Linux中CPU亲和性(affinity) 6.4 Netfilter和iptablesnetfilter/iptables 简介 [^1]:李兴华. Java开发实战经典[M]. 北京: 清华大学出版社, 2009, 281-282. [^2]:潘建南. Java线程的6种状态及切换(透彻讲解) [^3]:积极解放. JAVA 线程状态及转化 [^4]:超人. 线程调度算法分析 [^5]:___Blue_H. 分时操作系统与实时操作系统 [^6]:Coding-lover. 进程和线程调度算法 [^7]:诺贝尔爱情奖. Java线程的优先级 [^8]:潜行的Q. java的线程优先级和守护线程 [^9]:FangZheng. 线程的优先级 [^10]:强迫症Kobe. 为什么优先级高的线程并不一定先执行 [^11]:taxue505. 多级反馈队列调度算法 [^12]:比特流. 多线程的代价及上下文切换 [^13]:易霂. 6种Linux进程间的通信方式]]></content>
      <categories>
        <category>JAVA知识点梳理</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01| 职业未来发展]]></title>
    <url>%2F2019%2F03%2F28%2F01-%E8%81%8C%E4%B8%9A%E6%9C%AA%E6%9D%A5%E5%8F%91%E5%B1%95%2F</url>
    <content type="text"><![CDATA[1. 职业晋升通道这里用图1表示JAVA从业者的职位晋升过程。。。。。 从图1可以看出在经历1~3年从工程师晋升到高级工程师后，有两个方向可以选择；一个是走技术方向，另一个是走管理方向，先分别讨论如下。 1.1 技术方向 重点培养自己以下3种能力：(1) 技术攻坚能力(2) 架构设计(3) 专业知识需要做到疑难问题的排查、大型项目的功能拆分、技术品牌的塑造等；具体工作有原理实现、注重框架能力的培养；更深一层的还有大规模高并发场景，高可用可扩展措施和方案，业务的抽象和架构能力，分布式服务设计原则的理解等。 1.2 管理方向 重点培养自己以下3种能力：(1) 团队管理(2) 项目管理(3) 沟通协作偏重于团队把控，需要让团队形成技术战斗力，利用一切资源推进项目，让团队完成作战目标。另外做好团 队内和跨团队的沟通协作也是很重要的一块 * 需要重点说明一下，这两个方向没有明显边界，也就是说做管理的不会远离架构设计，做技术专家也需要带队，二者的区分在于侧重点不同，前者更偏向于技术架构而后者更偏向于管理项目推进。 PS：在面试被问及相关问题时，可参考如下例子： 答：从过往的经验来看，我对项目的整体规划、管理推进，在任务推进协调沟通方面有过突出的表现，所以我的职业规划是成为一名优秀的技术经理，并以管理方向为发展目标。（这样答，面试官可能会对你的相关经历产生兴趣。） 2. 常见技术级别划分 职级 工作年限 B（百度） A（阿里） T（腾讯） 备注 工程师 1~3年 多为校招内部晋升，较少为社招 高级工程师 2~5年 T4 P5 T2-2 技术主力，公司看重此级别人才的培养与成长 资深工程师 3~6年 T5 P6 T2-3 技术主力，公司看重此级别人才的培养与成长 技术专家 4~8年 T6 P7 T3-1 一般需要5年从业经验以上 高级技术专家 5~10年 T7 P8 T3-3 一般需要5年从业经验以上 3.如何选择公司和岗位 在换工作时，应聘公司有多个技术岗位，需要都投吗？手里有多个offer，如何进行决策？应当选钱多的还是大平台、福利待遇好的？ 一般来说可从以下几个维度进行考虑(1) 公司规模大小 大厂适合镀金，提高身价 (2) 业务线或团队的重要程度 核心业务适合长期稳定的发展，在核心团队对自身能力和经验提升得较快； 边缘业务有因公司战略调整而被裁掉的风险。综合这两点来说，大公司核心业务竞争压力大，小公司边缘业务应尽量避免；对于工作1~3年的推荐去小公司核心业务，因为职业生涯前期需要更多的基础知识历练场景。 (3) 个人条件的匹配程度 首先需要对自身条件进行评估，评估因素应包含岗位要求、业务方向、自身能力兴趣经验，匹配度与面试成功率成正比，匹配度越高将越利于以后个人的职业发展。 总结就是：优先选择核心业务和与自己条件匹配度高的岗位。 4.面试流程具体面试流程参见图2。 前置面试需要确定是否有笔试、电话面试、上机编程等，同时需要沟通好相关细节，如电话面试时间，上机编程是否需要自带电脑等等（现多为邮件发送笔试地址，用浏览器即可）; 技术一面为正式面试的开始，有1~2位面试官，以考察基础知识与实际应用能力为主，时长一小时左右；可能要求手写小算法，如排序、字符串处理等； 技术二面仍以技术为主，侧重于考察技术深度，比如项目经历、架构能力、算法等。面试时长一小时左右，可能要求画出项目的架构图或交互流程图等，并对项目存在的问题和改进方案进行询问；（规模较小的公司到二面就结束了） 技术三面注重考察项目经历和架构设计，还会设计到职业规划、职业兴趣，技术视野等方面的问题，以架构能力、技术敏感度和发展潜力为主；（少部分公司存在技术四面，如Tencent在较高岗位的面试中，存在跨部门的交叉面试，面试内容与技术三面内容基本相同） 人事面一般考察个人发展规划，上家公司离职原因，价值观，薪资待遇等，如果特别期望进入该公司，不可因为1~2k导致因小失大，因为工作前期以积累为主，三年后谈待遇也不迟。 上级领导面为公司级高管面试，这种非技术面视情况而定，一般为1~2面。可能简单询问工作经历，对公司的看法，对行业的看法，未来规划等，一般无原则性错误均可顺利通过。总结：（1）面试前询问时候有电话面试、笔试、上机等前置面试等；（2）技术一面二面偏重实际工作能力，技术二面三面偏重架构能力和发展能力；（3）二面与三面通常决定入职后的职位级别，也就直接对应着与HR谈薪资的底气了，应当好好表现。 面试前的准备工作对面试能否成功起着关键作用，面试成功的三个重要因素：能力、心态、沟通。所以面试前应该做好哪些准备工作？ 能力（1）了解应聘公司及岗位信息（2）系统复习基础知识（3）对负责过的项目进行提炼，从架构方面重新梳理总结项目经历（4）对经典框架原理、使用场景和实现方式进行学习（5）对常考考点进行专项突击，阅读常考考点源码（6）对业务方面进行有针对性的加分准备，比如面试中间件方向岗位，可以突出自己有存储中间件的开发经历，有过链路协议设计经历等。心态（1）面试前多渠道搜集面试公司岗位所属团队平均福利等资料信息，增加信心；（2）当面临压力面试时，需要多给予自己心里暗示，控制情绪；沟通（1）提前准备一个简单有特色的自我介绍，主要描述自己的技术特长和职业优势，禁忌谈及兴趣爱好星座等不重要内容；（2）关于不会的问题，应主动坦白并提出自己的解题思路，不然容易造成冷场；另外也可以选择询问面试官能够换个问题；（3）当没有听明白面试官的问题时，不要着急作答，应及时沟通确认问题；（4）注意面试细节，如面试微表情，面试过程中应尽量不要皱眉、控制坐姿和手势、注意语速、表达逻辑清晰观点明确，不要随意打断面试官，表现出谦虚有礼的面试态度等。另外可以观察面试官的反应，如果TA在简历上奋笔疾书，说明你提供的信息有用；如果停下来很长时间不写了，应提醒自己是否跑题；若面试官表现出不耐烦或深呼吸，应注意自己是否领会了面试官的考察意图，可以再次询问。 面试考察点一般分为硬技能和软实力（1）硬技能：基础知识的掌握、过往的项目经验、系统架构的设计能力、对不同框架工具的综合应用能力；（2）软实力：逻辑思维的灵活与否、沟通表达协作能力、项目管理推进能力、新技术学习思考能力、培养潜力； 不同职级面试考察的区别（1）初/中级工程师 首先是能完成分配的研发任务，面试官就偏重于基础知识掌握、逻辑思维的灵活性、有无培养潜力；其次是过往项目经历与学习思考能力；出于对工作年限的考虑，对架构能力、管理推进、沟通协作能力不作过高要求；（2）高级工程师一般需要独立完成功能模块或是子项目的设计与开发，比初/中级工程师对项目经验、学习思考、架构能力、管理推进、沟通协作能力有更高要求，特别是项目经验与学习思考能力；（3）技术专家在高级工程师的要求上，对项目架构、项目经验、管理推进、协作沟通能力有相当高要求，能够独立负责一个项目，做好项目架构，完成功能模块的拆解和任务分配，推进团队内外部的事务，协调资源管理进度，带领团队完成任务目标。提示：软实力突出会对技术工程师的职业生涯大大加分！ 硬技能学习的四大部分详情参见图3]]></content>
      <categories>
        <category>JAVA知识点梳理</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>职业发展]</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[00| 前言：构建能力框架]]></title>
    <url>%2F2019%2F03%2F27%2F00-%E6%9E%84%E5%BB%BA%E8%83%BD%E5%8A%9B%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[Java技术目前应用广泛，工作求职者众多，取得高薪报酬是码农自身水平的直接体现，这里将Java求职中需要掌握的内容分为以下3个部分。 1. 基础部分 技术岗位与面试流程 计算机基础 JVM原理 多线程 设计模式 数据结构与算法2. 应用部分 常用工具集 常用框架 缓存 队列 数据库3. 综合部分 系统架构设计 微服务架构 容器化 找工作面对的3个问题 如何准备简历？ 简历直接决定着求职者能否获得面试机会，所以简历的重要性不言而喻！有数据显示80%的简历通不过初步筛查，原因有：(1) 工作或项目经验描述不到位(2) 不懂得如何包装技术特长(3) 不占优的学历放在了最重要的位置(4) 排版较乱，语言不精练 补充：不可进行不看岗位的盲目海投，要根据岗位要求及时调整简历；简历中工作年限，对口经验、学历、简历美观度都需要留意。 面试官会考什么问题？ 公司所属行业和工作年限要求都对求职者有着不同的侧重点，现举例分析如下：(1) 从公司所属行业来看① 社交门户类，多考察大规模高并发场景的应用与架构能力；② O2O类，多考察综合能力；③ 互联网金融类，多考察逻辑能力与高可用、安全领域的经验。(2) 从工作年限上来看① 校招，考察基础知识和逻辑思维，以及培养潜力；② 初中级工程师，考察知识的广度和基础知识的应用；③ 高级或资深工程师，考察综合能力，如对基本原理的深入理解和对各种知识的灵活运用。 补充：针对面试官抛出的问题，回答时需要尽量发散扩展；建议在面试前对公司业务和岗位职责作针对性的准备，以提高面试成功率。 如何提升晋级？ 技术的更新迭代速度快，学习要系统，需要先建立一套知识体系或思维框架，然后再丰富完善其中细节。]]></content>
      <categories>
        <category>JAVA知识点梳理</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>职业发展</tag>
      </tags>
  </entry>
</search>
